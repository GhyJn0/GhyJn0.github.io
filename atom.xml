<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FSRM</title>
  
  <subtitle>浮生若梦</subtitle>
  <link href="https://hexofox.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://hexofox.gitee.io/"/>
  <updated>2023-03-27T11:41:23.450Z</updated>
  <id>https://hexofox.gitee.io/</id>
  
  <author>
    <name>FSRM</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Contrastive Multi-View Representation Learning on Graphs</title>
    <link href="https://hexofox.gitee.io/2023/04/02/MVGRL/"/>
    <id>https://hexofox.gitee.io/2023/04/02/MVGRL/</id>
    <published>2023-04-02T12:36:33.000Z</published>
    <updated>2023-03-27T11:41:23.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="论文阅读05-Contrastive-Multi-View-Representation-Learning-on-Graphs：MVRLG"><a href="#论文阅读05-Contrastive-Multi-View-Representation-Learning-on-Graphs：MVRLG" class="headerlink" title="论文阅读05-Contrastive Multi-View Representation Learning on Graphs：MVRLG"></a>论文阅读05-Contrastive Multi-View Representation Learning on Graphs：MVRLG</h1><h2 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h2><p>论文地址：<a href="https://arxiv.org/abs/2006.05582"> Contrastive Multi-View Representation Learning on Graphs (arxiv.org)</a></p><p>论文代码：<a href="https://github.com/kavehhassani/mvgrl">kavehhassani/mvgrl (github.com)</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/607a6a0e4c31">MVGRL：多视图图对比学习 - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/BlairGrowing/p/16060887.html">论文解读（MVGRL）Contrastive Multi-View Representation Learning on Graphs - 加微信X466550探讨 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;论文阅读05-Contrastive-Multi-View-Representation-Learning-on-Graphs：MVRLG&quot;&gt;&lt;a href=&quot;#论文阅读05-Contrastive-Multi-View-Representation-Learni</summary>
      
    
    
    
    
    <category term="论文" scheme="https://hexofox.gitee.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="深度聚类" scheme="https://hexofox.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E8%81%9A%E7%B1%BB/"/>
    
    <category term="图深度学习" scheme="https://hexofox.gitee.io/tags/%E5%9B%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="多视图" scheme="https://hexofox.gitee.io/tags/%E5%A4%9A%E8%A7%86%E5%9B%BE/"/>
    
    <category term="对比" scheme="https://hexofox.gitee.io/tags/%E5%AF%B9%E6%AF%94/"/>
    
  </entry>
  
  <entry>
    <title>Multi-View Attribute Graph Convolution Networks for Clustering</title>
    <link href="https://hexofox.gitee.io/2023/03/26/MAGCN/"/>
    <id>https://hexofox.gitee.io/2023/03/26/MAGCN/</id>
    <published>2023-03-26T13:06:11.000Z</published>
    <updated>2023-03-27T13:13:29.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="论文阅读04-Multi-View-Attribute-Graph-Convolution-Networks-for-Clustering：MAGCN"><a href="#论文阅读04-Multi-View-Attribute-Graph-Convolution-Networks-for-Clustering：MAGCN" class="headerlink" title="论文阅读04-Multi-View Attribute Graph Convolution Networks for Clustering：MAGCN"></a>论文阅读04-Multi-View Attribute Graph Convolution Networks for Clustering：MAGCN</h1><h2 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h2><p>论文地址：<a href="https://www.ijcai.org/proceedings/2020/411">Multi-View Attribute Graph Convolution Networks for Clustering | IJCAI</a></p><p>论文代码：<a href="https://github.com/IMKBLE/MAGCN">MAGCN </a></p><h2 id="1-多视图属性聚类：MAGCN"><a href="#1-多视图属性聚类：MAGCN" class="headerlink" title="1.多视图属性聚类：MAGCN"></a><strong>1.多视图属性聚类：MAGCN</strong></h2><h3 id="1-存在问题：GNN-融入Multi-View-Graph"><a href="#1-存在问题：GNN-融入Multi-View-Graph" class="headerlink" title="1.存在问题：GNN 融入Multi-View Graph"></a>1.存在问题：GNN 融入Multi-View Graph</h3><p>1）他们<strong>不能将指定学习的不同权重的分配给邻域内的不同节点；</strong></p><p> 2）他们可能<strong>忽略了进行节点属性和图结构的重构</strong>以提高鲁棒性； </p><p>3）对于<strong>不同视图之间的一致性关系</strong>，<strong>没有明确考虑相似距离度量</strong>。</p><h3 id="2-解决问题：MAGCN"><a href="#2-解决问题：MAGCN" class="headerlink" title="2.解决问题：MAGCN"></a>2.解决问题：MAGCN</h3><p>本论文提出了一种新的<strong>多视图属性图卷积网络</strong>，用于<strong>聚类（MAGCN）多视图属性的图结构数据</strong></p><ol><li><p>为了将可<code>学习的权重分配给不同的节点</code>，MAGCN开发了<code>具有注意机制的多视图属性图卷积编码器</code>，用于<code>从多视图图数据中学习图嵌入</code>。</p></li><li><p><code>属性和图重建均由 MAGCN 的图卷积解码器</code>计算。</p></li><li><p>将<code>多视图图数据之间</code>的<code>几何关系和概率分布一致性</code>纳入M<code>AGCN的一致嵌入编码器中</code>，以进一步促进聚类任务。</p></li></ol><p><code>编码器1：</code></p><p><strong>开发多视图属性图注意力网络</strong>以<strong>减少噪声/冗余并学习多视图图数据的图嵌入特征。</strong></p><p><code>编码器2：</code></p><p><strong>开发一致的嵌入编码器来</strong>捕获<strong>不同视图之间的几何关系和概率分布的一致性，</strong>从而<strong>自适应地为多视图属性找到一致的聚类嵌入空间</strong>。</p><h2 id="2-MAGCN模型创新点"><a href="#2-MAGCN模型创新点" class="headerlink" title="2.MAGCN模型创新点"></a>2.MAGCN模型创新点</h2><ol><li>我们提出了一种<strong>新的多视图属性图卷积网络</strong>，用于对<strong>多视图属性的图结构数据进行聚类</strong>。</li><li>我们开发了<strong>具有注意机制的多视图属性图卷积编码器</strong>，以<strong>减少多视图图数据的噪声/冗余</strong>。</li><li>此外，还考虑了<strong>节点属性和图结构的重构以提高鲁棒性</strong>。<strong>一致性嵌入编码器旨在通过探索不同视图的几何关系和概率分布一致性来提取多个视图之间的一致性信息</strong>。</li></ol><h2 id="3-MAGCN-模型"><a href="#3-MAGCN-模型" class="headerlink" title="3.MAGCN 模型"></a>3.MAGCN 模型</h2><h3 id="1-MAGCN-先验知识"><a href="#1-MAGCN-先验知识" class="headerlink" title="1.MAGCN 先验知识"></a>1.MAGCN 先验知识</h3><blockquote><ol><li>MAGCN的编码器</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303271434749.png" alt="image-20230327143439693"></p><p>这个X 特征重构中GAT来自于：[<a href="https://arxiv.org/abs/1905.10715">1905.10715] Graph Attention Auto-Encoders (arxiv.org)</a></p><blockquote><ol start="2"><li>GAT 和GATE 的区别</li></ol></blockquote><p>GATE:<a href="https://arxiv.org/abs/1905.10715">1905.10715] Graph Attention Auto-Encoders (arxiv.org)</a></p><p>GAT: <a href="https://arxiv.org/abs/1710.10903">1710.10903] Graph Attention Networks (arxiv.org)</a></p><p><img src="C:\Users\life\AppData\Roaming\Typora\typora-user-images\image-20230327201208314.png" alt="image-20230327201208314"></p><p><img src="C:\Users\life\AppData\Roaming\Typora\typora-user-images\image-20230327200539965.png" alt="image-20230327200539965"></p><p><img src="C:\Users\life\AppData\Roaming\Typora\typora-user-images\image-20230327200624428.png" alt="image-20230327200624428"></p><blockquote><ol start="2"><li>图中参数</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303271437321.png" alt="image-20230327143739274"></p><h3 id="2-模型架构图"><a href="#2-模型架构图" class="headerlink" title="2.模型架构图"></a>2.模型架构图</h3><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303271445814.png" alt="image-20230327144517730"></p><p><code>MAGCN模型主要有两个编码器</code>组成：<strong>多视图属性图卷积编码器</strong>和<strong>一致嵌入编码器</strong></p><p>用于聚类的多视图属性图卷积网络 (MAGCN) 的框架。</p><ol><li>具有注意机制的多视图属性图卷积编码器：它们用于<code>从节点属性和图数据（图结构）中学习图嵌入</code>。<code>执行属性和图形重建以进行端到端学习</code>。 </li></ol><ol start="2"><li>一致嵌入编码器(Consistent embedding encoders)：通过<code>几何关系和概率分布的一致性</code>，<code>进一步在多个视图之间获得一致的聚类嵌入</code>。</li></ol><p><strong>MAGCN 模型训练过程：</strong></p><p>我们首先将多视图图数据 Xm，通过多视图属性图卷积编码器 编码为图嵌入。将 Hm 馈入一致的嵌入编码器并获得一致的聚类嵌入 Z。<code>聚类过程最终在由 Z 计算出的理想嵌入内在描述空间上进行</code>。</p><h3 id="3-MAGCN-模块详细"><a href="#3-MAGCN-模块详细" class="headerlink" title="3. MAGCN 模块详细"></a>3. MAGCN 模块详细</h3><h4 id="1-多视图属性图卷积编码器：Multi-view-Attribute-Graph-Convolution-Encoder"><a href="#1-多视图属性图卷积编码器：Multi-view-Attribute-Graph-Convolution-Encoder" class="headerlink" title="1. 多视图属性图卷积编码器：Multi-view Attribute Graph Convolution Encoder"></a>1. 多视图属性图卷积编码器：Multi-view Attribute Graph Convolution Encoder</h4><p>主要作用：在多视图属性图卷积编码器中，第一个编码器将多视图节点属性矩阵和图结构映射到图嵌入空间。</p><h4 id="2-一致嵌入编码器：Consistent-embedding-encoders"><a href="#2-一致嵌入编码器：Consistent-embedding-encoders" class="headerlink" title="2.一致嵌入编码器：Consistent embedding encoders"></a>2.一致嵌入编码器：Consistent embedding encoders</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;论文阅读04-Multi-View-Attribute-Graph-Convolution-Networks-for-Clustering：MAGCN&quot;&gt;&lt;a href=&quot;#论文阅读04-Multi-View-Attribute-Graph-Convolution</summary>
      
    
    
    
    
    <category term="论文" scheme="https://hexofox.gitee.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="深度聚类" scheme="https://hexofox.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E8%81%9A%E7%B1%BB/"/>
    
    <category term="图深度学习" scheme="https://hexofox.gitee.io/tags/%E5%9B%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="多视图" scheme="https://hexofox.gitee.io/tags/%E5%A4%9A%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>R-GAE</title>
    <link href="https://hexofox.gitee.io/2023/03/23/R-GAE/"/>
    <id>https://hexofox.gitee.io/2023/03/23/R-GAE/</id>
    <published>2023-03-23T13:49:58.000Z</published>
    <updated>2023-03-23T13:50:45.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h2><p>论文地址：[<a href="https://arxiv.org/abs/2107.08562">2107.08562] Rethinking Graph Auto-Encoder Models for Attributed Graph Clustering (arxiv.org)</a></p><p>论文代码：<a href="https://github.com/nairouz/R-GAE">nairouz/R-GAE (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;论文信息&quot;&gt;&lt;a href=&quot;#论文信息&quot; class=&quot;headerlink&quot; title=&quot;论文信息&quot;&gt;&lt;/a&gt;论文信息&lt;/h2&gt;&lt;p&gt;论文地址：[&lt;a href=&quot;https://arxiv.org/abs/2107.08562&quot;&gt;2107.08562] R</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>商品折扣后的最终价格</title>
    <link href="https://hexofox.gitee.io/2023/03/21/1475.%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/"/>
    <id>https://hexofox.gitee.io/2023/03/21/1475.%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/</id>
    <published>2023-03-21T02:09:29.000Z</published>
    <updated>2023-03-21T02:10:31.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1475-商品折扣后的最终价格"><a href="#1475-商品折扣后的最终价格" class="headerlink" title="1475. 商品折扣后的最终价格"></a><a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/">1475. 商品折扣后的最终价格</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1475-商品折扣后的最终价格&quot;&gt;&lt;a href=&quot;#1475-商品折扣后的最终价格&quot; class=&quot;headerlink&quot; title=&quot;1475. 商品折扣后的最终价格&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/fi</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://hexofox.gitee.io/tags/leetcode/"/>
    
    <category term="单调栈" scheme="https://hexofox.gitee.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>分类合集、</title>
    <link href="https://hexofox.gitee.io/2023/03/21/leetcode%E5%88%86%E7%B1%BB%E5%90%88%E9%9B%86/"/>
    <id>https://hexofox.gitee.io/2023/03/21/leetcode%E5%88%86%E7%B1%BB%E5%90%88%E9%9B%86/</id>
    <published>2023-03-21T02:07:09.000Z</published>
    <updated>2023-03-26T05:07:05.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-分类合集"><a href="#leetcode-分类合集" class="headerlink" title="leetcode  分类合集"></a>leetcode  分类合集</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="1-解决问题"><a href="#1-解决问题" class="headerlink" title="1. 解决问题"></a>1. 解决问题</h3><p>单调栈解决的问题：</p><p>求下一个更大的元素、求下一个更小的元素、求左右两边第一个更大/更小的元素。</p><p>求<strong>右边</strong>第一个较大的数字：<strong>逆序</strong>遍历，<strong>单调递减栈</strong> —— 如果<strong>当前元素大于等于栈顶元素</strong>，则栈顶出栈。<br>求<strong>右边</strong>第一个较小的数字：<strong>逆序</strong>遍历，<strong>单调递增栈</strong> —— 如果<strong>当前元素小于等于栈顶元素</strong>，则栈顶出栈。<br>求<strong>左边</strong>第一个较大的数字：<strong>正序</strong>遍历，<strong>单调递减栈</strong> —— 如果<strong>当前元素大于等于栈顶元素</strong>，则栈顶出栈。<br>求<strong>左边</strong>第一个较小的数字：<strong>正序</strong>遍历，<strong>单调递增栈</strong> —— 如果<strong>当前元素小于等于栈顶元素</strong>，则栈顶出栈</p><p><code>总结： </code></p><p><code>右边 较大，较小都是逆序遍历</code><strong>：正序遍历也可以  。</strong></p><p><code> 左边 较大  较小 都是正序遍历</code></p><p>参考链接：<a href="https://blog.csdn.net/chuangshangbeidong/article/details/122638512">https://blog.csdn.net/chuangshangbeidong/article/details/122638512</a></p><h4 id="1475-商品折扣后的最终价格"><a href="#1475-商品折扣后的最终价格" class="headerlink" title="1475. 商品折扣后的最终价格"></a><a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/">1475. 商品折扣后的最终价格</a></h4><p><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度 - 力扣（LeetCode）</a>：用下标</p><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II - 力扣（LeetCode）</a> 逆序，正序都可以</p><h3 id="1-模板总结：寻找当前元素-下一个更大的元素"><a href="#1-模板总结：寻找当前元素-下一个更大的元素" class="headerlink" title="1.模板总结：寻找当前元素 下一个更大的元素"></a>1.模板总结：寻找当前元素 下一个更大的元素</h3><h4 id="1-逆序-栈中存值"><a href="#1-逆序-栈中存值" class="headerlink" title="1.  逆序 栈中存值"></a>1.  逆序 栈中存值</h4><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> dailyTemperatures(vector<int>& nums) &#123;             // 寻找下一个更大的数：        // 1.栈存储 数组的值        // 2.栈采用递减        int n=nums.size();// 数组的长度        stack<int> st;// 初始化一个栈        vector<int> res(n,0);// 初始化一个和nums 同样大小的数组，存储结果        for(int i=n-1;i>=0;i--)&#123;            while(!st.empty() && st.top()<nums[i] )// 栈顶小于当前的值 ，pop                st.pop();            int result;//            if (st.empty())//当前栈为空，说明后面不存在比他大的值复制为0                result=0;            else                result=st.top();//dandan            st.push(nums[i]);// 把当前元素压入栈            res[i]=result;// 把找到的结果压入到 res数组中                   &#125;        return res;    &#125;&#125;;</code></pre><p><strong><code>上面的代码还可优化：</code></strong></p><p><strong><code>不需要开辟新的数组res;由于 nums[i]从后往前确定，同时st栈中存储了nums[i]的值，所以可以直接把result的值直接赋值给nums[i]</code></strong></p><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> dailyTemperatures(vector<int>& nums) &#123;             // 寻找下一个更大的数：        // 1.栈存储 数组的值        // 2.栈采用递减        int n=nums.size();// 数组的长度        stack<int> st;// 初始化一个栈        for(int i=n-1;i>=0;i--)&#123;            while(!st.empty() && st.top()<nums[i] )// 栈顶小于当前的值 ，pop                st.pop();            int result;//            if (st.empty())//当前栈为空，说明后面不存在比他大的值复制为0                result=0;            else                result=st.top();//dandan            st.push(nums[i]);// 因为这个时候已经存储一份nums[i]的值            nums[i]=result;// 所以此时就算修改nums[i] 也没有影响        &#125;        return nums;    &#125;&#125;;</code></pre><h4 id="2-逆序-栈中存下标"><a href="#2-逆序-栈中存下标" class="headerlink" title="2. 逆序 栈中存下标"></a>2. 逆序 栈中存下标</h4><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> dailyTemperatures(vector<int>& nums) &#123;        //         // 寻找下一个更大的数：        // 1.栈存储 数组的下标        // 2.栈采用递减        int n=nums.size();// 数组的长度        stack<int> st;// 初始化一个栈,存储的是nums 的下标        vector<int> res(n,0);// 初始化一个和nums 同样大小的数组，存储结果        for(int i=n-1;i>=0;i--)&#123;            while(!st.empty() && nums[st.top()]<nums[i] )// 栈顶小于当前的值 pop                st.pop();            if (st.empty())//当前栈为空，说明后面不存在比他大的值复制为0                res[i]=0;            else                res[i]=nums[st.top()];//  此时st 栈中存储的是下标，故将值压入到 res数组中            st.push(i);// 把当前元素的下标压入栈                    &#125;        return res;     &#125;&#125;;</code></pre><p><code>重点：此时要用res 数组存储最后的结果，为啥不能省略，用nums[i]=代替，因为此时st 栈存出的是下标，不能再是 nums中的值，此时如果用nums[i] 代替的时候，修改了nums中的原始值，接下来在res[i]=nums[st.top()]时，nums[st.top()]值时修改了的nums的值</code></p><h4 id="3-正序遍历-存下标"><a href="#3-正序遍历-存下标" class="headerlink" title="3. 正序遍历 存下标"></a>3. 正序遍历 存下标</h4><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> dailyTemperatures(vector<int>& nums) &#123;        //         // 寻找下一个更大的数：        // 1.栈存储 数组的值        // 2.栈采用递减        int n=nums.size();// 数组的长度        stack<int> st;// 初始化一个栈,存储的是nums 的下标        vector<int> res(n,0);// 初始化一个和nums 同样大小的数组，存储结果        for(int i=0;i<n;i++)&#123;            while(!st.empty() && nums[st.top()]<nums[i] )&#123;//从前往后遍历，当nums[i]>栈顶表示 ，找到了故                res[st.top()]=nums[i];//此时栈中存储的时下标，故栈顶的下标即是所要求的下标 复制nums[i]                st.pop();            &#125;            st.push(i);// 把当前元素的下标压入栈        &#125;        return res;     &#125;&#125;;</code></pre><p><code>重点 ：此时正序遍历存值，是写不出来。</code></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></p><p><a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></p><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></p><p><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></p><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a>：<a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/jian-dan-yi-dong-xiang-jie-ru-xia-by-yuanninesuns/">简单易懂，详解如下 - 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcode-分类合集&quot;&gt;&lt;a href=&quot;#leetcode-分类合集&quot; class=&quot;headerlink&quot; title=&quot;leetcode  分类合集&quot;&gt;&lt;/a&gt;leetcode  分类合集&lt;/h1&gt;&lt;h2 id=&quot;单调栈&quot;&gt;&lt;a href=&quot;#单调栈&quot;</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://hexofox.gitee.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Deep graph clustering with enhanced feature representations for community detection</title>
    <link href="https://hexofox.gitee.io/2023/03/20/EFR-DGC/"/>
    <id>https://hexofox.gitee.io/2023/03/20/EFR-DGC/</id>
    <published>2023-03-20T07:05:20.000Z</published>
    <updated>2023-03-23T13:45:20.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="论文阅读03-EFR-DGC-Enhanced-Feature-Representations-for-Deep-Graph-Clustering"><a href="#论文阅读03-EFR-DGC-Enhanced-Feature-Representations-for-Deep-Graph-Clustering" class="headerlink" title="论文阅读03-EFR-DGC:Enhanced Feature Representations for Deep Graph Clustering"></a>论文阅读03-EFR-DGC:Enhanced Feature Representations for Deep Graph Clustering</h1><h2 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h2><p>论文地址：<a href="https://link.springer.com/article/10.1007/s10489-022-03381-y">Deep graph clustering with enhanced feature representations for community detection | SpringerLink</a></p><p>论文代码：<a href="https://github.com/grcai/DGC-EFR">https://github.com/grcai/DGC-EFR</a></p><h2 id="1-存在问题"><a href="#1-存在问题" class="headerlink" title="1.存在问题"></a>1.存在问题</h2><ol><li><strong>DAEGC在处理拓扑关系 方面取得了成功，</strong>但<strong>深度图聚类通常无法充分学习节点的属性信息</strong>。 节点特征信息学习不足。======<strong>图模型通常更关注拓扑信息而忽略节点属性的重要性</strong>。</li></ol><p>​    <code>DAEGC 这篇论文</code>中证明了：<strong>图注意力网络构建图自动编码器</strong>，作为<strong>更强大的学习者来提取足够的拓扑信息进行聚类</strong>：<code>EFR-DGC  拓扑关系（结构信息）： 通过利用DAEGC 中的图注意力机制的编码器，来处理拓扑关系和属性信息融合</code>。</p><ol start="2"><li><strong>结构深度聚类网络（SDCN）</strong>和<strong>深度融合聚类网络（DFCN）</strong>将节点的结构信息整合到深度聚类中,<strong>图模型的能力有限</strong>以及缺乏足够的模型优化自监督信息，这<strong>两者仍然存在特征表示不足的问题</strong>：</li></ol><p>​    <code>SDCN这篇论文</code>中证明了：<strong>自动编码器</strong>，作为**<code>来学习层次的属性关系</code>**。<code>EFR-DGC  属性关系（节点特征信息）： 通过利用SDCN 中的AE编码器，来学习层次的属性关系。</code></p><h2 id="2-EFR-DGC解决问题"><a href="#2-EFR-DGC解决问题" class="headerlink" title="2.EFR-DGC解决问题"></a>2.EFR-DGC解决问题</h2><p>提出一种改进的特征表示方法，用于发现社区中的深度图聚类。</p><ol><li>首先构造一个具有<code>多个全连接层的基本自动编码器 (AE)</code>来<code>学习层次属性信息</code>，</li><li>然后将<code>AE学习到的属性信息，其传递给图自动编码器（GAE）</code>的神经层。<code>图自编码器接收到的分层属性信息与其提取的拓扑关系有机地组合</code>，以<code>生成用于聚类的增强的特征表示</code>。</li><li>其次，<code>设计了一自监督机制来优化深度图聚类模型</code>，该机制利用<code>两个自动编码器的重构损失</code>和<code>聚类损失作为自监督信息，有效地指导模型更新</code>。这样克服了生成表示中<code>属性信息不足的问题，从而更有利于社区发现</code>。</li></ol><p><strong>优点长处：</strong></p><p>与 <strong>SDCN 和 DFCN 中使用的简单图卷积网络相比</strong>，我们的<strong>图自动编码器能够通过为相邻节点分配不同的权重来很好地处理它们的属性和拓扑信息</strong></p><h2 id="3-模型"><a href="#3-模型" class="headerlink" title="3.模型"></a>3.模型</h2><h3 id="1-模型架构图"><a href="#1-模型架构图" class="headerlink" title="1. 模型架构图"></a>1. 模型架构图</h3><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201621519.png" alt="image-20230320162121435"></p><p><strong>EFR-DGC模型架构 主要由3个模块组成</strong>： <strong><code>学习节点属性信息的基本编码器AE 来自SCDN论文</code></strong>, 学**<code>习图的结构信息即拓扑结构信息，并融合属性信息的带有注意力机制的图编码器 来自DAEGC 论文</code>，**以及<code>带有自监督的聚类模块</code>**。</p><h3 id="2-模型的模块详细介绍"><a href="#2-模型的模块详细介绍" class="headerlink" title="2.模型的模块详细介绍"></a>2.模型的模块详细介绍</h3><h4 id="1-AE编码器-学习属性信息"><a href="#1-AE编码器-学习属性信息" class="headerlink" title="1. AE编码器 学习属性信息"></a>1. AE编码器 学习属性信息</h4><p>我们使用<code>具有多个全连接层的基本自动编码器 (AE)</code> 从<code>原始特征数据X</code>中学习<code>分层属性信息</code>，并将其<code>学习到的信息嵌入到潜在空间中的紧凑特征表示中</code>和SCDN中论文一模一样。</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201700080.png" alt="AE"></p><h4 id="2-带有注意力机制的GAE"><a href="#2-带有注意力机制的GAE" class="headerlink" title="2.带有注意力机制的GAE"></a>2.带有注意力机制的GAE</h4><p>我们通过图注意力网络 (GAT) 构建图自动编码器 (GAE)，并将其与基本 AE 相结合以生成增强的特征表示。</p><blockquote><ol><li>编码器encoding</li></ol></blockquote><p>　<code>EFR-DGC 认为图具有复杂的结构关系，建议在</code>编码器中利用高阶邻居<code>。我们通过</code>考虑图中的 t 阶邻居节点获得邻近矩阵M： t参数可以根据实验结果，自己调节，也即是输入参数`</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211653841.png" alt="image-20230321165331742"></p><p><strong>接下来计算顶点之间的图注意力系数: 顶点间的图注意力是不对成的 即 aij 不等于aji</strong></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211654466.png" alt="image-20230321165406389"></p><p><strong>图注意层得到图注意力自动编码器的编码器部分层级更新:</strong></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211654350.png" alt="image-20230321165433300"></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211655796.png" alt="image-20230321165523738"></p><blockquote><ol start="2"><li>解码器decoding</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211657198.png" alt="image-20230321165701147"></p><blockquote><ol start="3"><li>损失函数计算</li></ol></blockquote><p> 采用交叉熵损失函数：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211657883.png" alt="image-20230321165737844"></p><h4 id="3-自监督机制"><a href="#3-自监督机制" class="headerlink" title="3. 自监督机制"></a>3. 自监督机制</h4><p><strong>我们使用学生 t 分布 作为函数来计算节点 i 的特征表示 zi 与聚类中心 uj 之间的相似度：聚类中心 u 是用基于 Z 的 K-means 初始化的。</strong></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211706043.png" alt="image-20230321170602984"></p><p><strong><em>qiu\</em>表示节点i属于簇u的概率，将其看作是每个节点的软聚类分配标签，如果值越大，那么可信度越高</strong> 。通过平方运算将这种可信度放大，</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211706635.png" alt="image-20230321170636596"></p><p>自训练聚类模块的损失函数采用KL 散度：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211707924.png" alt="image-20230321170708897"></p><p><strong>聚类损失然后迫使当前分布 Q 逼近目标分布 P ，从而将这些“置信分配”设置为软标签来监督 Q 的嵌入学习</strong></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211707129.png" alt="image-20230321170731078"></p><h4 id="4-总损失函数"><a href="#4-总损失函数" class="headerlink" title="4. 总损失函数"></a>4. 总损失函数</h4><p>🔤KL散度被视为聚类损失。整体学习目标由两部分组成，即基本AE和GAE的重构损失，以及聚类损失：🔤</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211708229.png" alt="image-20230321170812167"></p><h4 id="5-算法流程图"><a href="#5-算法流程图" class="headerlink" title="5. 算法流程图"></a>5. 算法流程图</h4><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303211736726.png" alt="image-20230321173645666"></p><h3 id="3-实验结果分析"><a href="#3-实验结果分析" class="headerlink" title="3. 实验结果分析"></a>3. 实验结果分析</h3><blockquote><ol><li>比较方法分析</li></ol></blockquote><p><strong>K-means[48]是<code>经典聚类算法</code>的代表。</strong></p><p> <strong>AE、DEC 和 IDEC 代表了<code>深度学习方</code>法，它们通过神经网络学习聚类任务的<code>潜在数据表示</code>。</strong></p><p> <strong>GAE/VGAE、SDCN 和我们的基线方法 DAEGC  是通过<code>图神经网络学习潜在数据表示</code>的<code>深度图聚类方法</code>。</strong></p><blockquote><ol start="2"><li>模型好的原因</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303232013524.png" alt="image-20230323201311472"></p><p>原因是我们的<code>EFRDGC考虑了数据属性信息</code>，为节点分区提供了重要依据。同时，<code>自监督机制在指导模型优化方面</code>也发挥着重要作用。结果，<code>EFR-DGC生成消除了节点特征表示中的属性不足</code>，以<code>提高同一社区内的节点凝聚力</code>并减<code>少不同社区之间的重叠。</code></p><p><strong>即 SDCN 模型中 AE 模块能有效提取 节点的属性信息。解决节点的属性不足能力。</strong></p><p><strong>即DAEGC 模型中带有GAT 的GAE ，能有效提取图的结构的信息。并有效融合节点的属性信息。</strong></p><blockquote><ol start="3"><li>DBLP 和cora数据集实验分析</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303232009113.png" alt="image-20230323200901921"></p><p>原因一：</p><p><strong>DBLP 和 Cora 比 ACM 和 Citeseer 中的更密集</strong>。即 <code>DBLP 和 Cora 的相邻矩阵更密集</code>。<code>节点之间更密集的连接通常意味着更复杂的关系。</code> <code>EFR-DGC 模型</code>中的<code>图注意力网络具有更多在处理此类数据方面的优势</code>，因为<code>它可以学习不同邻域的权重更精确地表示居中节点的节点</code></p><p>原因二：</p><p>一方面，我们<code>构建了一个图自动编码器</code>，而<code>不是一个简单的图卷积网络</code>，作为<code>一个更强大的学习器来提取完整的拓扑信息即结构信息</code>。同时，<code>图自动编码器能够通过为相邻节点分配不同的权重来很好地处理相邻节点之间的关系</code>。另一方面，我们模型中的<code>两个自动编码器提供了更强的自监督信息</code>，可以有效地指导模型优化。因此，我<code>们的方法在处理具有复杂关系的社区数据时显示出巨大的优势即 处理节点密集的图</code></p><h3 id="4-消融实验分析"><a href="#4-消融实验分析" class="headerlink" title="4. 消融实验分析"></a>4. 消融实验分析</h3><h4 id="1-EFR-DGC-的有效性"><a href="#1-EFR-DGC-的有效性" class="headerlink" title="1. EFR-DGC 的有效性"></a>1. EFR-DGC 的有效性</h4><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303232022469.png" alt="image-20230323202222409"></p><p>我们分别使用 <code>AE、GAE 和 EFR-DGC 生成特征表示</code>。然后，<code>特征表示用于在四个数据集中进行聚类任务</code></p><p><strong>实验分析：</strong></p><p><code>单一的AE模型不擅长处理图数据</code>，因为<code>它没有考虑节点之间的关系： 即结构信息 没有考虑</code>。</p><p><strong>与GAE（DAEGC中使用的模型）相比</strong>，<code>EFR-DGC中的模块层包含更充分和可区分的属性信息</code></p><p><code>结果表明来自基本 AE 的分层属性信息可以帮助 GAE 丰富数据表达。 多维和多粒度信息，从而提高特征表达能力</code></p><h4 id="2-超参数"><a href="#2-超参数" class="headerlink" title="2. 超参数"></a>2. 超参数</h4><blockquote><ol><li>超参数是 中的 λ平衡了两个部分（AE 和 GAE）对隐藏表示的影响</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303232104394.png" alt="image-20230323210459335"></p><p>有两个重要的超参数决定了我们模型的性能。第一个超参数是 (12) 中的 λ，<code>它平衡了两个部分（AE 和 GAE）对隐藏表示的影响。</code>换句话说，<code>λ 决定了 GAE 层中的新隐藏表示从 AE 模块接收了多少属性信息</code>。我们<code>对 λ 进行了网格搜索，正如我们所见，当 λ 设置为 0.1 时，我们的模型在所有数据集上都达到了最高的精度</code></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303232101841.png" alt="image-20230323210100768"></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303232103776.png" alt="image-20230323210349720"></p><blockquote><ol start="2"><li>超参数 ε 控制聚类损失</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303232104296.png" alt="image-20230323210404236"></p><p>损失函数 (22) 中的第<code>二个超参数 ε 控制聚类损失的影响。</code>我们<code>进行实验以显示超参数对所有数据集的影响</code>。</p><p>图 5 <code>说明了我们的模型在参数集  &#123;0.01, 0.1, 1.0, 10, 100&#125; 中的性能变化。实验结果表明，当 ε = 1.0  时，我们的模型达到最佳性能。同时，我们的模型是稳健的，因为它不会随着参数值的变化而发生剧烈变化</code></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303232103505.png" alt="image-20230323210335444"></p><blockquote><ol start="3"><li>可视化特征表示</li></ol></blockquote><p>如图 6 所示，<code>**第一行对应于原始社区数据的分布，第二行对应于基本自动编码器的表示分布，最后一行对应于我们的 EFR-DGC 的表示分布</code>。正如我们所见，<code>单个 AE 或 GAE 生成的特征表示无法有效分离</code>。相反，我<code>们的方法可以减少不同社区的重叠，并使同一社区内的节点彼此封闭。</code>特别是，<code>与 GAE 模型（在我们的基线方法 DAEGC 中使用）相比，我们的模型增强了属性信息表示，从而提高了社区节点的可区分性</code>。</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303232106588.png" alt="image-20230323210654535"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;论文阅读03-EFR-DGC-Enhanced-Feature-Representations-for-Deep-Graph-Clustering&quot;&gt;&lt;a href=&quot;#论文阅读03-EFR-DGC-Enhanced-Feature-Representations</summary>
      
    
    
    
    
    <category term="论文" scheme="https://hexofox.gitee.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="深度聚类" scheme="https://hexofox.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E8%81%9A%E7%B1%BB/"/>
    
    <category term="图深度学习" scheme="https://hexofox.gitee.io/tags/%E5%9B%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口最大值</title>
    <link href="https://hexofox.gitee.io/2023/03/19/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://hexofox.gitee.io/2023/03/19/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2023-03-19T05:32:46.000Z</published>
    <updated>2023-03-19T07:20:41.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h1><h2 id="先验知识-deque"><a href="#先验知识-deque" class="headerlink" title="先验知识 deque"></a>先验知识 deque</h2><pre class=" language-c++"><code class="language-c++">c++ 中双向队列deque<int> q; //创建一个空队列int a;q.push_back(a); //将a元素放入q的最末端q.push_front(a); //将a元素放入q的最前端q.pop_back(); //弹出最后一个元素q.pop_front(); //弹出首元素q.back(); //获取最后一个元素的值q.front(); //获取首元素的值作者：NY2025xieyc链接：https://leetcode.cn/problems/sliding-window-maximum/solution/chua-dong-chuang-kou-zui-da-zhi-dan-diao-ao5i/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre class=" language-python"><code class="language-python">给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>sliding<span class="token operator">-</span>window<span class="token operator">-</span>maximum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class=" language-python"><code class="language-python">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">3</span>输出：<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>解释：滑动窗口的位置                最大值<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>               <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span>  <span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">3</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token number">5</span>  <span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">3</span> <span class="token number">1</span>  <span class="token number">3</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span><span class="token punctuation">]</span> <span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">5</span> <span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span>  <span class="token number">3</span><span class="token punctuation">]</span> <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">5</span> <span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span> <span class="token punctuation">[</span><span class="token number">5</span>  <span class="token number">3</span>  <span class="token number">6</span><span class="token punctuation">]</span> <span class="token number">7</span>       <span class="token number">6</span> <span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span> <span class="token punctuation">[</span><span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span><span class="token punctuation">]</span>      <span class="token number">7</span>来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>sliding<span class="token operator">-</span>window<span class="token operator">-</span>maximum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><h3 id="1-算法思路"><a href="#1-算法思路" class="headerlink" title="1. 算法思路"></a>1. 算法思路</h3><p>单调队列实现</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><blockquote><p> c++ 一</p></blockquote><pre class=" language-c++"><code class="language-c++">class Solution &#123;private:    class MyQueue &#123; //单调队列（从大到小）    public:        deque<int> que; // 使用deque来实现单调队列        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。        // 同时pop之前判断队列当前是否为空。        void pop(int value) &#123;            if (!que.empty() && value == que.front()) &#123;                que.pop_front();            &#125;        &#125;        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。        // 这样就保持了队列里的数值是单调从大到小的了。        void push(int value) &#123;            while (!que.empty() && value > que.back()) &#123;                que.pop_back();            &#125;            que.push_back(value);        &#125;        // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。        int front() &#123;            return que.front();        &#125;    &#125;;public:    vector<int> maxSlidingWindow(vector<int>& nums, int k) &#123;        MyQueue que;        vector<int> result;        for (int i = 0; i < k; i++) &#123; // 先将前k的元素放进队列            que.push(nums[i]);        &#125;        result.push_back(que.front()); // result 记录前k的元素的最大值        for (int i = k; i < nums.size(); i++) &#123;            que.pop(nums[i - k]); // 滑动窗口移除最前面元素            que.push(nums[i]); // 滑动窗口前加入最后面的元素            result.push_back(que.front()); // 记录对应的最大值        &#125;        return result;    &#125;&#125;;</code></pre><blockquote><p> c++ 二</p></blockquote><pre class=" language-c++"><code class="language-c++">//对c++ 一class Solution &#123;public:    vector<int> maxSlidingWindow(vector<int>& nums, int k) &#123;        vector<int> result;        deque<int> que;//双端队列 维护最大的单调队列        if(nums.size()<2)            return nums;// 数组为空 或者只有一个 返回原数组                for( int  i=0;i<nums.size();i++)&#123;            //1. 双端队列维护的单调队列 添加元素            while(!que.empty() &&   que.back()<nums[i])//判断当前                que.pop_back();//            que.push_back(nums[i]);            //2. 删除单调队列的元素            if(i>=k && nums[i-k]==que.front())                que.pop_front();            //3. 添加滑动窗口中的最大值            if(i>=k-1)                result.push_back(que.front());        &#125;        return result;           &#125;&#125;;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><pre class=" language-python"><code class="language-python">时间复杂度：O<span class="token punctuation">(</span>n<span class="token punctuation">)</span>，其中 n 是数组 nums 的长度。每一个下标恰好被放入队列一次，并且最多被弹出队列一次，因此时间复杂度为 O<span class="token punctuation">(</span>n<span class="token punctuation">)</span>。空间复杂度：O<span class="token punctuation">(</span>k<span class="token punctuation">)</span>。与方法一不同的是，在方法二中我们使用的数据结构是双向的，因此「不断从队首弹出元素」保证了队列中最多不会有超过 k<span class="token operator">+</span><span class="token number">1</span> 个元素，因此队列使用的空间为 O<span class="token punctuation">(</span>k<span class="token punctuation">)</span>。作者：LeetCode<span class="token operator">-</span>Solution链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>sliding<span class="token operator">-</span>window<span class="token operator">-</span>maximum<span class="token operator">/</span>solution<span class="token operator">/</span>hua<span class="token operator">-</span>dong<span class="token operator">-</span>chuang<span class="token operator">-</span>kou<span class="token operator">-</span>zui<span class="token operator">-</span>da<span class="token operator">-</span>zhi<span class="token operator">-</span>by<span class="token operator">-</span>leetco<span class="token operator">-</span>ki6m<span class="token operator">/</span>来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">代码随想录 (programmercarl.com)</a></p><p><a href="https://leetcode.cn/problems/sliding-window-maximum/solution/shuang-xiang-dui-lie-jie-jue-hua-dong-chuang-kou-2/">双向队列解决滑动窗口最大值 - 滑动窗口最大值 - 力扣（LeetCode）</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NjAxMDU5NA==&mid=2475920459&idx=1&sn=3f7a5d2c9d01d2d0b7e7aba0cf3140d7&chksm=ff22ebc6c85562d0726fbfeccf6e987b4d5b379e50942c981e7075a710eca10af38806833047&scene=178&cur_album_id=1961651953529159689#rd">队列，帮我搞一下这个滑动窗口最大值。 (qq.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;239-滑动窗口最大值&quot;&gt;&lt;a href=&quot;#239-滑动窗口最大值&quot; class=&quot;headerlink&quot; title=&quot;239. 滑动窗口最大值&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/sliding-window</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://hexofox.gitee.io/tags/leetcode/"/>
    
    <category term="队列和栈" scheme="https://hexofox.gitee.io/tags/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>用队列实现栈</title>
    <link href="https://hexofox.gitee.io/2023/03/19/235.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>https://hexofox.gitee.io/2023/03/19/235.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</id>
    <published>2023-03-19T04:30:48.000Z</published>
    <updated>2023-03-19T05:16:22.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre class=" language-c++"><code class="language-c++">请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。实现 MyStack 类：void push(int x) 将元素 x 压入栈顶。int pop() 移除并返回栈顶元素。int top() 返回栈顶元素。boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意：你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。来源：力扣（LeetCode）链接：https://leetcode.cn/problems/implement-stack-using-queues著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h2><pre class=" language-c++"><code class="language-c++">que.back();  返回最后一个元素que.empty();  如果队列空则返回真que.front();  返回第一个元素que.pop();  删除第一个元素que.push();  在末尾加入一个元素https://blog.csdn.net/weixin_42513339/article/details/89054438</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class=" language-c++"><code class="language-c++">输入：["MyStack", "push", "push", "top", "pop", "empty"][[], [1], [2], [], [], []]输出：[null, null, null, 2, 2, false]解释：MyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // 返回 2myStack.pop(); // 返回 2myStack.empty(); // 返回 False来源：力扣（LeetCode）链接：https://leetcode.cn/problems/implement-stack-using-queues著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="解题思想"><a href="#解题思想" class="headerlink" title="解题思想"></a>解题思想</h2><h3 id="1-思路-双队列"><a href="#1-思路-双队列" class="headerlink" title="1. 思路  双队列"></a>1. 思路  双队列</h3><ol><li><p>一个队列为主队列，一个为辅助队列</p></li><li><p>当入栈操作时，我们先将主队列内容导入辅助队列，然后将入栈元素放入主队列队头位置，再将辅助队列内容，依次添加进主队列即可。</p></li></ol><p>也可以用单队列实现</p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><blockquote><p>c++</p></blockquote><pre class=" language-c++"><code class="language-c++">class MyStack &#123;public:    queue<int> que;    /** Initialize your data structure here. */    MyStack() &#123;    &#125;    /** Push element x onto stack. */    void push(int x) &#123;        que.push(x);    &#125;    /** Removes the element on top of the stack and returns that element. */    int pop() &#123;        int size = que.size();        size--;        while (size--) &#123; // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部            que.push(que.front());            que.pop();        &#125;        int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了        que.pop();        return result;    &#125;    /** Get the top element. */    int top() &#123;        return que.back();    &#125;    /** Returns whether the stack is empty. */    bool empty() &#123;        return que.empty();    &#125;&#125;;</code></pre><blockquote><p>python</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        size<span class="token operator">=</span>len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">)</span>        size<span class="token operator">=</span>size<span class="token number">-1</span>        <span class="token keyword">while</span> size<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            size<span class="token operator">=</span>size<span class="token number">-1</span>        result<span class="token operator">=</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">[</span>len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MyStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MyStack()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># param_2 = obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.top()</span><span class="token comment" spellcheck="true"># param_4 = obj.empty()</span></code></pre><blockquote><p>复杂度分析</p></blockquote><pre class=" language-python"><code class="language-python">时间复杂度：入栈操作 O<span class="token punctuation">(</span>n<span class="token punctuation">)</span>，其余操作都是 O<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>，其中 n 是栈内的元素个数。入栈操作需要将队列中的 n 个元素出队，并入队 n<span class="token operator">+</span><span class="token number">1</span> 个元素到队列，共有 2n<span class="token operator">+</span><span class="token number">1</span> 次操作，每次出队和入队操作的时间复杂度都是 O<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>，因此入栈操作的时间复杂度是 O<span class="token punctuation">(</span>n<span class="token punctuation">)</span>。出栈操作对应将队列的前端元素出队，时间复杂度是 O<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>。获得栈顶元素操作对应获得队列的前端元素，时间复杂度是 O<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>。判断栈是否为空操作只需要判断队列是否为空，时间复杂度是 O<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>。空间复杂度：O<span class="token punctuation">(</span>n<span class="token punctuation">)</span>，其中 n 是栈内的元素个数。需要使用一个队列存储栈内的元素。</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/">https://leetcode.cn/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/</a><br><a href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html">代码随想录 (programmercarl.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;225-用队列实现栈&quot;&gt;&lt;a href=&quot;#225-用队列实现栈&quot; class=&quot;headerlink&quot; title=&quot;225. 用队列实现栈&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/implement-stack-u</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://hexofox.gitee.io/tags/leetcode/"/>
    
    <category term="队列和栈" scheme="https://hexofox.gitee.io/tags/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>用栈实现队列</title>
    <link href="https://hexofox.gitee.io/2023/03/19/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://hexofox.gitee.io/2023/03/19/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2023-03-19T02:08:48.000Z</published>
    <updated>2023-03-19T02:49:13.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre class=" language-c++"><code class="language-c++">请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：实现 MyQueue 类：void push(int x) 将元素 x 推到队列的末尾int pop() 从队列的开头移除并返回元素int peek() 返回队列开头的元素boolean empty() 如果队列为空，返回 true ；否则，返回 false说明：你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。来源：力扣（LeetCode）链接：https://leetcode.cn/problems/implement-queue-using-stacks著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class=" language-c++"><code class="language-c++">输入：["MyQueue", "push", "push", "peek", "pop", "empty"][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]解释：MyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false来源：力扣（LeetCode）链接：https://leetcode.cn/problems/implement-queue-using-stacks著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>队列的特性是 ：<strong>先入先出</strong>，而栈的特性是 ：<strong>先入后出</strong>。</p><p>知道两者特性之后，我们需要用<strong>两个栈来模拟队列的特</strong>性，<strong>一个栈为入队栈</strong>，<strong>一个栈为出对栈</strong>。</p><ol><li><p>当<strong>出队栈存在内容时</strong>，<strong>出队栈的栈顶，即为第一个出队的元素</strong>。</p></li><li><p>若出队栈无元素，我们的需求又是出队的话，我们就需要将<strong>入队栈的内容反序导入出队栈</strong>，然后<strong>弹出栈顶即可</strong>。</p></li></ol><h3 id="不同语言实现"><a href="#不同语言实现" class="headerlink" title="不同语言实现"></a>不同语言实现</h3><blockquote><p> c++</p></blockquote><pre class=" language-c++"><code class="language-c++">class MyQueue &#123;public:    stack<int> stIn;    stack<int> stOut;    /** Initialize your data structure here. */    MyQueue() &#123;    &#125;    /** Push element x to the back of queue. */    void push(int x) &#123;        stIn.push(x);    &#125;    /** Removes the element from in front of queue and returns that element. */    int pop() &#123;        // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）        if (stOut.empty()) &#123;            // 从stIn导入数据直到stIn为空            while(!stIn.empty()) &#123;                stOut.push(stIn.top());                stIn.pop();            &#125;        &#125;        int result = stOut.top();        stOut.pop();        return result;    &#125;    /** Get the front element. */    int peek() &#123;        int res = this->pop(); // 直接使用已有的pop函数        stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去        return res;    &#125;    /** Returns whether the queue is empty. */    bool empty() &#123;        return stIn.empty() && stOut.empty();    &#125;&#125;;</code></pre><p>时间复杂度为何是0(1):<a href="https://leetcode.cn/problems/implement-queue-using-stacks/solution/sha-shi-jun-tan-fu-za-du-ya-wo-de-suan-f-gb6d/">啥是「均摊复杂度」呀？我的算法击败 100%，是 O(1) 算法了吧？ - 用栈实现队列 - 力扣（LeetCode）</a></p><ul><li>时间复杂度：<code>pop()</code> 和 <code>peek()</code> 操作都是均摊 <em>O</em>(1)</li><li>空间复杂度：<em>O</em>(<em>n</em>)</li></ul><blockquote><p>python</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        in主要负责push，out主要负责pop        """</span>        self<span class="token punctuation">.</span>stack_in <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack_out <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        有新元素进来，就往in里面push        """</span>        self<span class="token punctuation">.</span>stack_in<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Removes the element from in front of queue and returns that element.        """</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None                <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack_out<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack_out<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack_in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack_out<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack_in<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack_out<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Get the front element.        """</span>        ans <span class="token operator">=</span> self<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>stack_out<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ans<span class="token punctuation">)</span>        <span class="token keyword">return</span> ans    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        只要in或者out有元素，说明队列不为空        """</span>        <span class="token keyword">return</span> <span class="token operator">not</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack_in <span class="token operator">or</span> self<span class="token punctuation">.</span>stack_out<span class="token punctuation">)</span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/solution/sha-shi-jun-tan-fu-za-du-ya-wo-de-suan-f-gb6d/">啥是「均摊复杂度」呀？我的算法击败 100%，是 O(1) 算法了吧？ - 用栈实现队列 - 力扣（LeetCode）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;232-用栈实现队列&quot;&gt;&lt;a href=&quot;#232-用栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;232. 用栈实现队列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/implement-queue-u</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://hexofox.gitee.io/tags/leetcode/"/>
    
    <category term="栈和队列" scheme="https://hexofox.gitee.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Structural Deep Clustering Network</title>
    <link href="https://hexofox.gitee.io/2023/03/15/SCDN/"/>
    <id>https://hexofox.gitee.io/2023/03/15/SCDN/</id>
    <published>2023-03-15T05:07:10.000Z</published>
    <updated>2023-03-20T06:15:20.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="论文阅读02-Structural-Deep-Clustering-Network"><a href="#论文阅读02-Structural-Deep-Clustering-Network" class="headerlink" title="论文阅读02-Structural Deep Clustering Network"></a>论文阅读02-Structural Deep Clustering Network</h1><h2 id="模型创新点"><a href="#模型创新点" class="headerlink" title="模型创新点"></a>模型创新点</h2><ol><li><p>我们提出了一种用于<code>深度聚类的新型结构深度聚类网络 (SDCN)</code>。所提出的 SDCN 有效地将<code>自动编码器和 GCN 的优势</code>与<code>新颖的交付算子和双自监督模块结合在一起</code>。据我们所知，这是<code>第一次明确地将结构信息应用于深度聚类</code>。</p></li><li><p><code>我们对提出的 SDCN 进行了理论分析</code>，并<code>证明 GCN 为 DNN 表示提供了近似的二阶图正则化</code>，并且在 SDCN 中<code>学习的数据表示等同于具有不同阶结构信息的表示的总和</code>。基于我们的理论分析，<code>SDCN中GCN模块的过度平滑问题将得到有效缓解</code>。</p></li></ol><h2 id="深度聚类"><a href="#深度聚类" class="headerlink" title="深度聚类"></a>深度聚类</h2><h3 id="1-存在问题：这篇论文之前"><a href="#1-存在问题：这篇论文之前" class="headerlink" title="1. 存在问题：这篇论文之前"></a>1. 存在问题：这篇论文之前</h3><p>尽管深度聚类取得了成功，但他们通常**<code>关注数据本身的特征</code>**，因此在<code>学习表示时很少考虑数据的结构</code></p><h3 id="2-结构信息添加到深度聚类解决问题"><a href="#2-结构信息添加到深度聚类解决问题" class="headerlink" title="2. 结构信息添加到深度聚类解决问题"></a>2. 结构信息添加到深度聚类解决问题</h3><blockquote><ol><li>深度聚类需要考虑哪些结构信息？</li></ol></blockquote><p> (众所周知，<code>结构信息表明数据样本之间的潜在相似性</code>。然而，数据的结构通常非常复杂，即<code>不仅存在样本之间的直接关系（也称为一阶结构）</code>，而且<code>还存在高阶结构</code>。</p><p><strong>以<code>二阶结构为例</code>**，这意味着对于</strong><code>没有直接关系的两个样本</code><strong>，如果</strong>它们<code>有很多共同的邻居样本</code><strong>，它们</strong><code>应该仍然具有相似的表示</code>**。仅在深度聚类中利用<code>低阶结构是远远不够的</code>，如何有<code>效地考虑高阶结构是首要问题</code>；</p><p>本篇论文如何解决：</p><p>为了捕获结构信息，我们<code>首先构建了一个 K 最近邻 (KNN) 图</code>，它能够揭示数据的底层结构。为了<code>从 KNN 图中捕获低阶和高阶结构信息</code>，我们提出了<code>一个由多个图卷积层组成的 GCN 模块，以学习 GCN 特定的表示。</code></p><blockquote><ol start="2"><li>结构信息和深度聚类之间的关系是什么？</li></ol></blockquote><p><code>深度聚类的基本组成部分是深度神经网络 (DNN)</code>，例如自动编码器。<code>自编码器的网络架构非常复杂，由多层组成。每层捕获不同的潜在信息。并且数据之间还存在各种类型的结构信息</code>。那么，autoencoder中不同结构和不同层之间的关系是什么？<code>可以使用结构以某种方式对自动编码器学习的表示进行正则化</code>，但是，另一方面，也可以直接从结构本身学习表示。</p><p>本篇论文如何解决：</p><p>为了将结构信息引入深度聚类，我们引入了<code>一个自动编码器模块</code>来从<code>原始数据中学习自动编码器特定的表示</code>。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="1-模型架构图"><a href="#1-模型架构图" class="headerlink" title="1. 模型架构图"></a>1. 模型架构图</h3><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201413345.png" alt="image-20230315143854736"></p><p>从<strong>模型框架中可以看出该模型主要包含四个模块</strong>：<strong>KNN模块、DNN模块、GCN模块和双重自监督模块</strong>。</p><ol><li><strong>我们首先基于（非图数据）原始数据构建 KNN 图。如果是图数据直接输入到GCN</strong></li><li><strong>然后我们将原始数据和 KNN 图分别输入自动编码器和 GCN。</strong></li><li><strong>然后我们将自动编码器的每一层与相应的 GCN 层连接起来，将自动编码器特定的表示结构感知表示中。</strong></li><li><strong>最后，我们通过了一种双重自监督机制来监督自动编码器和 GCN 的训练进度</strong></li></ol><h3 id="2-模型模块详细介绍"><a href="#2-模型模块详细介绍" class="headerlink" title="2. 模型模块详细介绍"></a>2. 模型模块详细介绍</h3><h4 id="1-KNN模块"><a href="#1-KNN模块" class="headerlink" title="1.KNN模块"></a>1.KNN模块</h4><p>该模块主要是对非图数据进行处理，通过K近邻算法构建一个K近邻的图，首先要构造相似性矩阵，从相似性矩阵中选择节点前K个作为邻居。：　根据节点特征　计算任意节点之间的相似度关系，选择与自身最大的ｋ个连接成边。</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201413546.png" alt="image-20230315145504207"></p><h4 id="2-DNN-模块：-自动编码器AE"><a href="#2-DNN-模块：-自动编码器AE" class="headerlink" title="2.DNN 模块： 自动编码器AE"></a>2.DNN 模块： 自动编码器AE</h4><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201413634.png" alt="image-20230315152157602"></p><h4 id="3-GCN模块"><a href="#3-GCN模块" class="headerlink" title="3. GCN模块"></a>3. GCN模块</h4><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201413062.png" alt="image-20230315161441574"> <img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201413515.png" alt="image-20230315162713623"></p><h4 id="4-双重自监督模块"><a href="#4-双重自监督模块" class="headerlink" title="4.双重自监督模块"></a>4.双重自监督模块</h4><blockquote><ol><li>第一重自监督模块</li></ol></blockquote><p>​    我们使用<strong>t-分布</strong>来衡量<strong>嵌入节点Hi</strong> 和<strong>簇中心节点Uj</strong> 之间的相似性。</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414696.png" alt="image-20230315222043866"></p><p>其他论文中公式：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414500.png" alt="image-20230308105502219"></p><p>*<strong>qij表示节点i属于簇j的概率，将其看作是每个节点的软聚类分配标签，如果值越大，那么可信度越高</strong> 。通过平方运算将这种可信度放大：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414641.png" alt="image-20230315162906791"></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414895.png" alt="image-20230315165412843"></p><p>自训练聚类模块的损失函数采用KL 散度：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414313.png" alt="image-20230315162923459"></p><p><strong>聚类损失然后迫使当前分布 Q 逼近目标分布 P ，从而将这些“置信分配”设置为软标签来监督 Q 的嵌入学习</strong></p><blockquote><ol start="2"><li>第二重自监督模块</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414053.png" alt="image-20230315221527375"></p><p><strong>目标函数优势：</strong></p><p>（1）与传统的<code>多分类损失函数</code>相比，<code>KL散度以更“温和”的方式更新整个模型</code>，防止数据表示受到严重扰动；</p><p> (2) <code>GCN和DNN模块都统一在同一个优化目标上</code>，使得它们的结果在训练过程中趋于一致。因为D<code>NN模块和GCN模块的目标是逼近目标分布P</code>，这两个模块之间有很强的联系，所以我们称之为<code>双重自监督机制</code>。</p><h4 id="5-SCDN-损失函数"><a href="#5-SCDN-损失函数" class="headerlink" title="5. SCDN 损失函数"></a>5. SCDN 损失函数</h4><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414451.png" alt="image-20230315222211636"></p><h4 id="6-SCDN-算法流程"><a href="#6-SCDN-算法流程" class="headerlink" title="6.SCDN 算法流程"></a>6.SCDN 算法流程</h4><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414193.png" alt="image-20230315222808748"></p><h4 id="7-SCDN实验结果"><a href="#7-SCDN实验结果" class="headerlink" title="7. SCDN实验结果"></a>7. SCDN实验结果</h4><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414033.png" alt="image-20230316111630188"></p><ol><li>我们的方法 SDCN 和 SDCNQ 在所有六个数据集中都取得了最好的结果,原因是 <code>SDCN 成功地将结构信息整合到深度聚类中，双自监督模块引导自编码器和 GCN 的更新，使它们相互增强。</code></li><li><code>SDCN 通常比 SDCNQ 获得更好的聚类结果</code>。原因是 S<code>DCN 使用包含 GCN 学习的结构信息的表示，而 SDCNQ类似于DAEGC 主要使用自动编码器学习的表示</code>。在Reuters数据集上============应用GCN的一个重要前提是构建噪声较小的KNN图。</li></ol><h3 id="3-实验数据详细分析"><a href="#3-实验数据详细分析" class="headerlink" title="3. 实验数据详细分析"></a>3. 实验数据详细分析</h3><h4 id="1-变体分析："><a href="#1-变体分析：" class="headerlink" title="1.变体分析："></a>1.变体分析：</h4><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414887.png" alt="image-20230319154446755"></p><p><strong>和两种变体相比，SDCN 都取得了最好的性能。这证明了SDCN中的交替传递算子和 GCN 在提高聚类质量方面都发挥了重要作用。</strong></p><h4 id="2-传播层数分析"><a href="#2-传播层数分析" class="headerlink" title="2. 传播层数分析"></a>2. 传播层数分析</h4><p>为了研究 SDCN 是否受益于多层 GCN，我们改变了 GCN 模块的深度，同时保持 DNN 模块不变。</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414762.png" alt="image-20230319155454166"></p><p>结果分析：</p><ol><li>增加 SDCN 的GCN深度可以显着提高聚类性能。由于autoencoder中每一层学习到的representations不同，为了尽可能的保留信息，我们需要将autoencoder中学习到的representations全部放到对应的GCN层中。</li><li>scdn-2 比scdn-3的效果好。 1. 存在SDCN-3存在图过平滑问题，2. SDCN-3它使用的是H(2)，是编码器的中间层。该层生成的表示处于从原始数据到语义表示的过渡阶段，不可避免地会丢失一些底层信息，缺乏语义信息</li></ol><h4 id="3-AE输入到GCN中的交替算子中平衡因子"><a href="#3-AE输入到GCN中的交替算子中平衡因子" class="headerlink" title="3. AE输入到GCN中的交替算子中平衡因子"></a>3. AE输入到GCN中的交替算子中平衡因子</h4><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201414652.png" alt="image-20230319155826172"></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201415611.png" alt="image-20230319155849673"></p><p>  结果分析：</p><ol><li><p>发现平衡因子为0.5时效果最好：在四个数据集（Reuters、ACM、DBLP、Citeseer）中参数 ε = 0.5 的聚类精度达到最佳性能，这<strong>表明 GCN 模块和 DNN 模块的表示同等重要</strong>，SDCN 的改进取决于相互增强两个模块。</p></li><li><p> <strong>ε =0，时为标准的GCN模型，存在过渡平滑现象</strong>，与<strong>ε =1相比</strong>，我们可以<strong>发现即使将自动编码器学习到的少量表示注入 GCN 也有助于缓解过度平滑问题</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;论文阅读02-Structural-Deep-Clustering-Network&quot;&gt;&lt;a href=&quot;#论文阅读02-Structural-Deep-Clustering-Network&quot; class=&quot;headerlink&quot; title=&quot;论文阅读02-Str</summary>
      
    
    
    
    
    <category term="论文" scheme="https://hexofox.gitee.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="深度聚类" scheme="https://hexofox.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E8%81%9A%E7%B1%BB/"/>
    
    <category term="图深度学习" scheme="https://hexofox.gitee.io/tags/%E5%9B%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据集处理</title>
    <link href="https://hexofox.gitee.io/2023/03/08/%E6%95%B0%E6%8D%AE%E9%9B%86%E5%A4%84%E7%90%86/"/>
    <id>https://hexofox.gitee.io/2023/03/08/%E6%95%B0%E6%8D%AE%E9%9B%86%E5%A4%84%E7%90%86/</id>
    <published>2023-03-08T05:20:22.000Z</published>
    <updated>2023-03-08T05:20:53.557Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.aliyun.com/article/1138200">在torch_geometric.datasets中使用Planetoid手动导入Core数据集及发生相关错误解决方案-阿里云开发者社区 (aliyun.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/article/1138200&quot;&gt;在torch_geometric.datasets中使用Planetoid手动导入Core数据集及发生相关错误解决方案-阿里云开发者社区 (aliyun.com)&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="https://hexofox.gitee.io/2023/03/07/KMP/"/>
    <id>https://hexofox.gitee.io/2023/03/07/KMP/</id>
    <published>2023-03-07T07:44:50.000Z</published>
    <updated>2023-03-20T06:20:34.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMP-字符串快速匹配"><a href="#KMP-字符串快速匹配" class="headerlink" title="KMP 字符串快速匹配"></a>KMP 字符串快速匹配</h1><h2 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h2><p><strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了</strong></p><p><code>所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任</code></p><h2 id="2-KMP前缀表"><a href="#2-KMP前缀表" class="headerlink" title="2.  KMP前缀表"></a>2.  KMP前缀表</h2><blockquote><ol><li>前缀表作用</li></ol></blockquote><p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配</strong></p><blockquote><ol start="2"><li>前缀表如何记录</li></ol></blockquote><p>首先要知道<code>前缀表的任务</code>是当前位置匹配失败，<code>找到之前已经匹配上的位置</code>，再重新匹配，此也<code>意味着在某个字符失配时</code>，<code>前缀表会告诉你下一步匹配中</code>，<code>模式串应该跳到哪个位置</code>。</p><blockquote><ol start="3"><li>前缀表记录数据意义</li></ol></blockquote><p><strong>记录下标i之前（包括i）的字符串中，有多大长度的<code>相同前缀后缀</code></strong></p><h2 id="3-前缀和后缀"><a href="#3-前缀和后缀" class="headerlink" title="3. 前缀和后缀"></a>3. 前缀和后缀</h2><p>字符串的**<code>前缀</code>是指<code>不包含最后一个字符</code>的<code>所有以第一个字符开头的连续子串</code>**</p><p>**<code>后缀</code>是指<code>不包含第一个字符</code>的<code>所有以最后一个字符结尾的连续子串</code>**。</p><p><strong>注意事项：</strong></p><p><code>KMP 中前缀表</code>要求的是<code>相同前后缀的长度</code>。</p><h2 id="4-求前缀表和使用"><a href="#4-求前缀表和使用" class="headerlink" title="4. 求前缀表和使用"></a>4. 求前缀表和使用</h2><blockquote><ol><li>求前缀表</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201420864.png" alt="image-20230307161910833"></p><blockquote><ol start="2"><li>前缀表在使用</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201420593.png" alt="image-20230307162939331"></p><h2 id="5-KMP-代码实现"><a href="#5-KMP-代码实现" class="headerlink" title="5. KMP 代码实现"></a>5. KMP 代码实现</h2><h3 id="1-Next数组：前缀表"><a href="#1-Next数组：前缀表" class="headerlink" title="1. Next数组：前缀表"></a>1. Next数组：前缀表</h3><pre class=" language-c++"><code class="language-c++"> void getNext(int* next, const string& s) &#123;     /*     参数 i，j解释     i ： 指向后缀末尾位置  i=1       j ： 指向前缀末尾位置  j=0    还表示i 之前包含i这个字串最长相等前后缀的长度     我们要比较前缀和和后缀最长公共长度：     所以i=1 ,j=0 这个时候才可以比较。          next 前缀表过程     1. 初始化     2. 前后缀不同     3. 前后缀相同          */        int j = 0;        next[0] = 0;// 一个字符最长前后缀公共长度为0        for(int i = 1; i < s.size(); i++) &#123;            while (j > 0 && s[i] != s[j]) &#123; // j要保证大于0，因为下面有取j-1作为数组下标的操作                j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了                // 解释：kmp 匹配过程中碰到匹配不符合时候会看前一位的。这个和那个类似            &#125;            if (s[i] == s[j]) &#123;                j++;            &#125;            next[i] = j;        &#125;    &#125;</code></pre><h3 id="2-KMP匹配：找到模式串在文本串中第一次出现的位置"><a href="#2-KMP匹配：找到模式串在文本串中第一次出现的位置" class="headerlink" title="2. KMP匹配：找到模式串在文本串中第一次出现的位置"></a>2. KMP匹配：找到模式串在文本串中第一次出现的位置</h3><pre class=" language-c++"><code class="language-c++">int strStr(string haystack, string needle) &#123;        if (needle.size() == 0) &#123;            return 0;        &#125;        int next[needle.size()];        getNext(next, needle);        int j = 0;        for (int i = 0; i < haystack.size(); i++) &#123;            while(j > 0 && haystack[i] != needle[j]) &#123;                j = next[j - 1];            &#125;            if (haystack[i] == needle[j]) &#123;                j++;            &#125;            if (j == needle.size() ) &#123;                return (i - needle.size() + 1);            &#125;        &#125;        return -1;    &#125;&#125;;</code></pre><h2 id="6-KMP复杂度分析"><a href="#6-KMP复杂度分析" class="headerlink" title="6. KMP复杂度分析"></a>6. KMP复杂度分析</h2><ul><li>时间复杂度O(M+N)，</li><li>空间复杂度为O(M)</li></ul><h2 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7. 参考链接"></a>7. 参考链接</h2><p><a href="https://www.bilibili.com/video/BV1M5411j7Xx/?spm_id_from=pageDriver&vd_source=5e8f069711510b3788382a0a03ff38e5">帮你把KMP算法学个通透！（求next数组代码篇）_哔哩哔哩_bilibili</a></p><p><a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录 (programmercarl.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;KMP-字符串快速匹配&quot;&gt;&lt;a href=&quot;#KMP-字符串快速匹配&quot; class=&quot;headerlink&quot; title=&quot;KMP 字符串快速匹配&quot;&gt;&lt;/a&gt;KMP 字符串快速匹配&lt;/h1&gt;&lt;h2 id=&quot;1-算法思想&quot;&gt;&lt;a href=&quot;#1-算法思想&quot; cla</summary>
      
    
    
    
    
    <category term="字符串" scheme="https://hexofox.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="leetcode" scheme="https://hexofox.gitee.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>GAT</title>
    <link href="https://hexofox.gitee.io/2023/03/07/GAT/"/>
    <id>https://hexofox.gitee.io/2023/03/07/GAT/</id>
    <published>2023-03-07T07:14:25.000Z</published>
    <updated>2023-03-20T06:17:39.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAT-图注意力"><a href="#GAT-图注意力" class="headerlink" title="GAT 图注意力"></a>GAT 图注意力</h1><h2 id="1-图数据结构两种特征"><a href="#1-图数据结构两种特征" class="headerlink" title="1. 图数据结构两种特征"></a>1. 图数据结构两种特征</h2><h3 id="1-图结构特征"><a href="#1-图结构特征" class="headerlink" title="1.图结构特征"></a>1.图结构特征</h3><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201417643.png" alt="image-20230307200830089"></p><h3 id="2-节点自己特征"><a href="#2-节点自己特征" class="headerlink" title="2. 节点自己特征"></a>2. 节点自己特征</h3><p><strong>除了图的结构之外**</strong>，每个<code>顶点还有自己的特征 ℎi</code>（通常是一个高维向量）。**<code>它可以使社交网络中每个用户的个体属性</code>；可以是生物网络中，每个蛋白质的性质；还可以使交通路网中，每个交叉口的车流量。</p><h2 id="2-GAT-计算过程"><a href="#2-GAT-计算过程" class="headerlink" title="2. GAT  计算过程"></a>2. GAT  计算过程</h2><h3 id="1-注意力系数-attentio-coeffiecient"><a href="#1-注意力系数-attentio-coeffiecient" class="headerlink" title="1. 注意力系数 attentio  coeffiecient"></a>1. 注意力系数 attentio  coeffiecient</h3><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201417413.png" alt="image-20230307203205573"></p><h3 id="2-加权求和（aggregate）"><a href="#2-加权求和（aggregate）" class="headerlink" title="2. 加权求和（aggregate）"></a>2. <strong>加权求和（aggregate）</strong></h3><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201417402.png" alt="image-20230307203800447"></p><h2 id="3-单层的GAT-代码实现"><a href="#3-单层的GAT-代码实现" class="headerlink" title="3. 单层的GAT 代码实现"></a>3. 单层的GAT 代码实现</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>functional <span class="token keyword">as</span> F<span class="token keyword">class</span> <span class="token class-name">GATLayer</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> in_features<span class="token punctuation">,</span> out_features<span class="token punctuation">,</span> dropout<span class="token punctuation">,</span> alpha<span class="token punctuation">,</span> concat<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>GATLayer<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dropout <span class="token operator">=</span> dropout  <span class="token comment" spellcheck="true"># dropout参数</span>        self<span class="token punctuation">.</span>in_features <span class="token operator">=</span> in_features  <span class="token comment" spellcheck="true"># 节点向量的特征维度</span>        self<span class="token punctuation">.</span>out_features <span class="token operator">=</span> out_features  <span class="token comment" spellcheck="true"># 经过GAT之后的特征维度</span>        self<span class="token punctuation">.</span>alpha <span class="token operator">=</span> alpha  <span class="token comment" spellcheck="true"># LeakyReLU参数 GAT 中设置0.2</span>        self<span class="token punctuation">.</span>concat <span class="token operator">=</span> concat  <span class="token comment" spellcheck="true"># 如果为true, 再进行elu激活</span>        <span class="token comment" spellcheck="true"># 定义可训练参数，即论文中的W和a</span>        self<span class="token punctuation">.</span>W <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>empty<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span>in_features<span class="token punctuation">,</span> out_features<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输入特征h是N I  w为 I O</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>xavier_uniform_<span class="token punctuation">(</span>self<span class="token punctuation">.</span>W<span class="token punctuation">.</span>data<span class="token punctuation">,</span> gain<span class="token operator">=</span><span class="token number">1.414</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># xavier初始化</span>        self<span class="token punctuation">.</span>a <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>empty<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> out_features<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># wh之后为N0</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>xavier_uniform_<span class="token punctuation">(</span>self<span class="token punctuation">.</span>a<span class="token punctuation">.</span>data<span class="token punctuation">,</span> gain<span class="token operator">=</span><span class="token number">1.414</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># xavier初始化</span>        <span class="token comment" spellcheck="true"># 定义leakyReLU激活函数</span>        self<span class="token punctuation">.</span>leakyrelu <span class="token operator">=</span> nn<span class="token punctuation">.</span>LeakyReLU<span class="token punctuation">(</span>self<span class="token punctuation">.</span>alpha<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> h<span class="token punctuation">,</span> adj<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        adj图邻接矩阵，维度[N,N]非零即一        h.shape: (N, in_features), self.W.shape:(in_features,out_features)        Wh.shape: (N, out_features)        '''</span>        Wh <span class="token operator">=</span> torch<span class="token punctuation">.</span>mm<span class="token punctuation">(</span>h<span class="token punctuation">,</span> self<span class="token punctuation">.</span>W<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 计算wh值 Wh.shape: (N, out_features)</span>        <span class="token comment" spellcheck="true"># Wh.shape (N, out_feature)</span>        <span class="token comment" spellcheck="true"># self.a.shape (2 * out_feature, 1)</span>        <span class="token comment" spellcheck="true"># Wh1&amp;2.shape (N, 1)</span>        <span class="token comment" spellcheck="true"># e.shape (N, N)</span>        Wh1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>Wh<span class="token punctuation">,</span> self<span class="token punctuation">.</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>out_features<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 计算a和whi</span>        Wh2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>Wh<span class="token punctuation">,</span> self<span class="token punctuation">.</span>a<span class="token punctuation">[</span>self<span class="token punctuation">.</span>out_features<span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># a和whj</span>        <span class="token comment" spellcheck="true"># broadcast add</span>        e <span class="token operator">=</span> self<span class="token punctuation">.</span>leakyrelu<span class="token punctuation">(</span>Wh1 <span class="token operator">+</span> Wh2<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 拼接输入到leakyrelu</span>        zero_vec <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">9e15</span> <span class="token operator">*</span> torch<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>e<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将没有链接的边设置为负无穷</span>        attention <span class="token operator">=</span> torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>adj <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> zero_vec<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># [N,N]</span>        <span class="token comment" spellcheck="true"># 表示如果邻接矩阵元素大于0时，则两个节点有连接，该位置的注意力系数保留</span>        <span class="token comment" spellcheck="true"># 否则需要mask设置为非常小的值，因为softmax的时候这个最小值会不考虑</span>        attention <span class="token operator">=</span> F<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>attention<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># softmax形状保持不变[N,N]，得到归一化的注意力全忠！</span>        attention <span class="token operator">=</span> F<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>attention<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dropout<span class="token punctuation">,</span> training<span class="token operator">=</span>self<span class="token punctuation">.</span>training<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># dropout,防止过拟合</span>        h_prime <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>attention<span class="token punctuation">,</span> Wh<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># [N,N].[N,out_features]=>[N,out_features]</span>        <span class="token comment" spellcheck="true"># 得到由周围节点通过注意力权重进行更新后的表示</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>concat<span class="token punctuation">:</span>            <span class="token keyword">return</span> F<span class="token punctuation">.</span>elu<span class="token punctuation">(</span>h_prime<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> h_prime    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__ <span class="token operator">+</span> <span class="token string">' ('</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>in_features<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">' -> '</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>out_features<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">')'</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># x = torch.randn(6, 10)</span>    <span class="token comment" spellcheck="true"># adj = torch.tensor([[0, 1, 1, 0, 0, 0],</span>    <span class="token comment" spellcheck="true">#                     [1, 0, 1, 0, 0, 0],</span>    <span class="token comment" spellcheck="true">#                     [1, 1, 0, 1, 0, 0],</span>    <span class="token comment" spellcheck="true">#                     [0, 0, 1, 0, 1, 1],</span>    <span class="token comment" spellcheck="true">#                     [0, 0, 0, 1, 0, 0, ],</span>    <span class="token comment" spellcheck="true">#                     [0, 0, 0, 1, 1, 0]])</span>    <span class="token comment" spellcheck="true"># my_gat = GATLayer(10, 5, 0.2, 0.2)</span>    x <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>    adj <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                        <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                        <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>                        <span class="token punctuation">]</span><span class="token punctuation">)</span>    my_gat <span class="token operator">=</span> GATLayer<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>my_gat<span class="token punctuation">(</span>x<span class="token punctuation">,</span> adj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ————————————————</span><span class="token comment" spellcheck="true"># 版权声明：本文为CSDN博主「锵锵锵锵~蒋」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><span class="token comment" spellcheck="true"># 原文链接：https://blog.csdn.net/weixin_43629813/article/details/129278266</span></code></pre><p>参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/592857570">图神经网络-图注意力（GAT）详解及代码实现 - 知乎 (zhihu.com)</a></p><p><a href="https://www.bilibili.com/video/BV1wP411T7dr/">https://www.bilibili.com/video/BV1wP411T7dr/</a></p><p><a href="https://blog.csdn.net/weixin_43629813/article/details/129278266">(39条消息) 图注意网络GAT理解及Pytorch代码实现【PyGAT代码详细注释】_gat代码解读_锵锵锵锵~蒋的博客-CSDN博客</a></p><p><a href="https://www.bilibili.com/video/BV1wP411T7dr/?spm_id_from=333.788&vd_source=5e8f069711510b3788382a0a03ff38e5">图神经网络系列讲解及代码实现-GAT 1_哔哩哔哩_bilibili</a></p><p><a href="https://blog.csdn.net/weixin_43629813/article/details/129278266">(39条消息) 图注意网络GAT理解及Pytorch代码实现【PyGAT代码详细注释】_gat代码解读_锵锵锵锵~蒋的博客-CSDN博客</a></p><h2 id="4-GATV2-GAT的修改"><a href="#4-GATV2-GAT的修改" class="headerlink" title="4. GATV2 (GAT的修改)"></a>4. GATV2 (GAT的修改)</h2><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201417645.png" alt="image-20230307204919334"></p><p>参考链接:[<a href="https://blog.csdn.net/adreammaker/article/details/128237743">论文导读] GATv2: 《how attentive are graph attention network?》ICLR2022_鱼与钰遇雨的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/545773430">ICLR 2022 更强大的GAT(GATv2)! - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/m0_47256162/article/details/127939970">【图神经网络论文整理】（二）—— HOW ATTENTIVE ARE GRAPH ATTENTION NETWORKS?：GATv2_༺࿈ 海洋༒之心 ࿈༻的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/574133050">26.How attentive are graph attention networks? - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/404826711">图卷积：从GCN到GAT、GraphSAGE - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/376140518">图神经网络13-图注意力模型GAT网络详解 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/weixin_43734080/article/details/127448525">(39条消息) 图卷积神经网络GCN、GAT的原理及Pytorch实现_gat pytorch_Dr.sky_的博客-CSDN博客</a></p><p><a href="https://www.bilibili.com/video/BV1T54y1H7Hs/?spm_id_from=333.337.search-card.all.click&vd_source=5e8f069711510b3788382a0a03ff38e5">简单快速教你理解图注意力网络graph attention network_哔哩哔哩_bilibili</a></p><p><a href="https://www.jianshu.com/p/a1dc22c3fa79">图神经网络：GAT图注意力网络原理和源码解读（tensorflow） - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/jiangchao98/article/details/121873202">(39条消息) 图神经网络及其Pytorch实现_pytorch 图神经网络_jiangchao98的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/jiebaoshayebuhui/article/details/127820577?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-127820577-blog-121873202.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-127820577-blog-121873202.pc_relevant_default&utm_relevant_index=1">(39条消息) PyTorch搭建图卷积神经网络（GCN）完成对论文分类及预测实战（附源码和数据集）_图卷积神经网络源码_showswoller的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GAT-图注意力&quot;&gt;&lt;a href=&quot;#GAT-图注意力&quot; class=&quot;headerlink&quot; title=&quot;GAT 图注意力&quot;&gt;&lt;/a&gt;GAT 图注意力&lt;/h1&gt;&lt;h2 id=&quot;1-图数据结构两种特征&quot;&gt;&lt;a href=&quot;#1-图数据结构两种特征&quot; class</summary>
      
    
    
    
    
    <category term="图神经网络" scheme="https://hexofox.gitee.io/tags/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Attributed Graph Clustering |A Deep Attentional Embedding Approach</title>
    <link href="https://hexofox.gitee.io/2023/03/06/DAEGC/"/>
    <id>https://hexofox.gitee.io/2023/03/06/DAEGC/</id>
    <published>2023-03-06T13:29:55.000Z</published>
    <updated>2023-03-20T06:41:46.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="论文阅读01-Attributed-Graph-Clustering-A-Deep-Attentional-Embedding-Approach"><a href="#论文阅读01-Attributed-Graph-Clustering-A-Deep-Attentional-Embedding-Approach" class="headerlink" title="论文阅读01-Attributed Graph Clustering: A Deep Attentional Embedding Approach"></a>论文阅读01-Attributed Graph Clustering: A Deep Attentional Embedding Approach</h1><h2 id="1-创新点idea"><a href="#1-创新点idea" class="headerlink" title="1. 创新点idea"></a>1. 创新点idea</h2><ol><li><strong>Two-step的图嵌入方法不是目标导向的，聚类效果不好，提出一种基于目标导向的属性图聚类框架。</strong></li></ol><p>所谓目标导向，就是说<strong>特征提取和聚类任务不是独立的</strong>，提<strong>取的特征要在一定程度上有利于聚类，</strong>那么如何实现？可以通过自训练聚类的方式，<strong>将隐藏图嵌入产生的软聚类分配与聚类联合优化</strong>。</p><ol start="2"><li><strong>提出图注意力自动编码器</strong></li></ol><h2 id="2-模型-model"><a href="#2-模型-model" class="headerlink" title="2. 模型 model"></a>2. 模型 model</h2><h3 id="1-two-step"><a href="#1-two-step" class="headerlink" title="1. two-step"></a>1. two-step</h3><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201415139.png" alt="image-20230308094038236"></p><p><code>two-step 步骤：深度学习</code>方法来学习紧凑<code>图嵌入 embedding</code>，在此<code>基础上应用的聚类方法</code></p><p><strong>two-step之前缺点：图嵌入的生成和聚类是两个独立的部分，通常会导致性能不佳。</strong></p><p><strong>这主要是因为图嵌入不是目标导向的，即专为特定的聚类任务而设计</strong></p><p><strong>DAEGC 解决办法</strong>：<code>让模型图嵌入和聚类之间联合优化</code></p><h3 id="2-模型架构图"><a href="#2-模型架构图" class="headerlink" title="2. 模型架构图"></a>2. 模型架构图</h3><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201415531.png" alt="image-20230308094148787"></p><p>​        <strong>DAEGC</strong>通过基于<strong>图注意力的自动编码器</strong>学习<strong>隐藏表示 Z</strong>，并使用<strong>自训练聚类模块对其进行操作</strong>，<code>该模块与自动编码器一起优化并在训练期间执行聚类.</code></p><p>DAEGC模型架构为两个部分：</p><ul><li><code>图注意力自动编码器部分</code></li><li><code>自训练聚类</code></li></ul><p>自然而然的，该任务的目标函数就由两部分组成，重建损失和聚类损失：L=L<em>r</em>+<em>γ</em>L<em>c</em> 。</p><h3 id="3-图注意力自动编码器"><a href="#3-图注意力自动编码器" class="headerlink" title="3. 图注意力自动编码器"></a>3. 图注意力自动编码器</h3><p>​            <strong>DAEGC</strong>这篇论文的编码器<strong>在GAT 的基础上修改 作为图编码</strong>。<strong>原GAT论文 仅考虑 1 阶相邻节点（一阶）以进行图注意力。</strong>　<code>DAEGC</code> 认为图具有复杂的结构关系，建议在<code>编码器中利用高阶邻居</code>。我们通过<code>考虑图中的 t 阶邻居节点获得邻近矩阵M： t参数可以根据实验结果，自己调节，也即是输入参数</code></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416881.png" alt="image-20230308094250108"></p><p><strong>接下来计算顶点之间的图注意力系数: 顶点间的图注意力是不对成的 即 aij 不等于aji</strong></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416969.png" alt="image-20230308100604102"></p><p>​        <strong>DAEGC 堆叠两层图注意层得到图注意力自动编码器的编码器部分:</strong></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416997.png" alt="image-20230308101653448"></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416727.png" alt="image-20230308101954296"></p><p>​        解码器采用简单的内积：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416545.png" alt="image-20230308104330299"></p><p>​        损失函数Lr：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416043.png" alt="image-20230308104411125"></p><h3 id="4-自训练聚类模块"><a href="#4-自训练聚类模块" class="headerlink" title="4. 自训练聚类模块"></a>4. 自训练聚类模块</h3><p>​    我们使用<strong>t-分布</strong>来衡量<strong>嵌入节点Zi</strong> 和<strong>簇中心节点Uu</strong> 之间的相似性。</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416300.png" alt="image-20230308105314822"></p><p>其他论文中公式：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416770.png" alt="image-20230308105502219"></p><p><strong><em>qiu</em>表示节点i属于簇u的概率，将其看作是每个节点的软聚类分配标签，如果值越大，那么可信度越高</strong> 。通过平方运算将这种可信度放大：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416902.png" alt="image-20230308105938080"></p><p>自训练聚类模块的损失函数采用KL 散度：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416128.png" alt="image-20230308110014750"></p><p><strong>聚类损失然后迫使当前分布 Q 逼近目标分布 P ，从而将这些“置信分配”设置为软标签来监督 Q 的嵌入学习</strong></p><p>​    因此DEAGC 模型总的损失函数L：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416277.png" alt="image-20230308111337066"></p><h3 id="5-DAEGC-算法流程图、"><a href="#5-DAEGC-算法流程图、" class="headerlink" title="5. DAEGC 算法流程图、"></a>5. DAEGC 算法流程图、</h3><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416624.png" alt="image-20230308123920017"></p><h3 id="6-DAEGC-模型参数和评价标准"><a href="#6-DAEGC-模型参数和评价标准" class="headerlink" title="6. DAEGC 模型参数和评价标准"></a>6. DAEGC 模型参数和评价标准</h3><p><strong>DAEGC 参数设定</strong>：</p><p><strong>我们将聚类系数 γ 设置为 10。我们考虑二阶邻居并设置 M = (B +B2)/2。编码器由一个 256 个神经元隐藏层和一个 16 个神经元嵌入层构成，适用于所有数据集</strong>。</p><p><strong>DAEGC 评价指标：</strong></p><p>使用四个指标 [Xia et al., 2014] 来评估聚类结果：**准确性 (ACC)、归一化互信息 (NMI)、F 分数和调整兰德指数 (ARI)**。</p><p><strong>更好的聚类结果应该会导致所有指标的值更高。</strong></p><h3 id="7-实验结果分析"><a href="#7-实验结果分析" class="headerlink" title="7.实验结果分析"></a>7.实验结果分析</h3><blockquote><ol><li>实验对比</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416410.png" alt="image-20230310123310585"></p><ol><li><p><code>同时使用图的结构和内容信息的方法</code>通常比<code>仅使用图的一侧信息的方法表现更好</code></p></li><li><p>DAEGC模型为啥好：</p><p><code>（1）我们采用了图注意力网络，有效地整合了图的内容和结构信息；</code> </p><p><code>（2） 我们的自训练聚类组件在提高聚类效率方面专业而强大</code></p></li></ol><blockquote><ol start="2"><li>嵌入层维度</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416374.png" alt="image-20230310123005772"></p><p><code>嵌入层维度分析：</code><br><strong><code>当嵌入维度从 4 个神经元增加到 16 个神经元时，聚类性能稳步上升；但是当我们进一步增加嵌入层的神经元时，性能会有所波动，尽管 ACC 和 NMI 分数总体上都保持良好</code></strong></p><blockquote><ol start="3"><li>可视化分析</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416372.png" alt="image-20230310123424500"></p><p>第一个可视化说明<code>仅使用图形注意自动编码器进行嵌入训练</code>，然后是显示后续相等时期的可视化，其中包含<code>自训练组件，直到最后一个是最终的嵌入可视化</code></p><h2 id="额外知识补充"><a href="#额外知识补充" class="headerlink" title="额外知识补充"></a>额外知识补充</h2><h3 id="student-t分布"><a href="#student-t分布" class="headerlink" title="student t分布"></a>student t分布</h3><p>对于 <code>i 样本和 j</code> 样本，我们使用 Student 的 <code>t 分布</code>作为核心来度量<code>嵌入点 hi 和聚类中心向量 μj</code> 之间的相似性，如下所示：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201416598.png" alt="image-20230306213807740"></p><p><code>qij</code>可以看作是将<code>样本i分配</code>给<code>聚类j的概率</code>，即软分配。</p><p><strong><code>注意点：</code></strong> <strong><code>t=1</code></strong>  </p><p>解释</p><p>我们无法在<strong>无监督环境中对验证集上的 t 进行交叉验证</strong>，并且<strong>学习它是多余的</strong>（van der Maaten，2009），我们让<strong>所有实验的 t= 1</strong>。</p><p><a href="https://zhuanlan.zhihu.com/p/50365577">无监督的深度嵌入式聚类分析 - 知乎 (zhihu.com)</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/50365577">无监督的深度嵌入式聚类分析 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/467248262">文献+代码—AAAI’20 对话系统新意图发现( Constrained Deep Adaptive Clustering with Cluster Refinement) - 知乎 (zhihu.com)</a></p><p><a href="https://www.marigold.website/readArticle?workId=102&author=Marigold&authorId=1000001">论文阅读02——《Attributed Graph Clustering: A Deep Attentional Embedding Approach》 (marigold.website)</a></p><h2 id="DAEGC-代码"><a href="#DAEGC-代码" class="headerlink" title="DAEGC 代码"></a>DAEGC 代码</h2><p>出现问题解决办法：</p><p><a href="https://developer.aliyun.com/article/1138200">在torch_geometric.datasets中使用Planetoid手动导入Core数据集及发生相关错误解决方案-阿里云开发者社区 (aliyun.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;论文阅读01-Attributed-Graph-Clustering-A-Deep-Attentional-Embedding-Approach&quot;&gt;&lt;a href=&quot;#论文阅读01-Attributed-Graph-Clustering-A-Deep-Attent</summary>
      
    
    
    
    
    <category term="论文" scheme="https://hexofox.gitee.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="深度聚类" scheme="https://hexofox.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E8%81%9A%E7%B1%BB/"/>
    
    <category term="图深度学习" scheme="https://hexofox.gitee.io/tags/%E5%9B%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>206. 反转链表</title>
    <link href="https://hexofox.gitee.io/2023/03/06/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://hexofox.gitee.io/2023/03/06/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-06T03:51:55.000Z</published>
    <updated>2023-03-20T06:23:45.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h1><h2 id="题目示例"><a href="#题目示例" class="headerlink" title="题目示例"></a>题目示例</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><pre class=" language-python"><code class="language-python">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h3><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201423262.png" alt="image-20230306120034233"></p><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;       ListNode *cur=NULL,*pre=head;       while(pre!=NULL)&#123;           ListNode *temp=pre->next;           pre->next=cur;           cur=pre;           pre=temp;       &#125;       return cur;    &#125;&#125;;</code></pre><p><a href="https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/">【反转链表】：双指针，递归，妖魔化的双指针 - 反转链表 - 力扣（LeetCode）</a></p><h3 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h3><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;       if(head==NULL ||head->next==NULL)// 1 表示没有节点，或者只有一个节点时候            return head;                ListNode *cur=reverseList(head->next);// 2        head->next->next=head;//3        head->next=NULL;//3        return cur;//2    &#125;&#125;;</code></pre><p><a href="https://leetcode.cn/problems/reverse-linked-list/solution/jian-dan-yi-dong-javac-pythonjsgo-dong-h-8hvk/">简单易懂Java/C++ /Python/js/go 动画讲解 - 反转链表 - 反转链表 - 力扣（LeetCode）</a></p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<strong>O(n)**，假设<code>n</code>是列表的长度，时间复杂度是</strong>O(n)**。</li><li>空间复杂度：**O(1)**。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;206-反转链表&quot;&gt;&lt;a href=&quot;#206-反转链表&quot; class=&quot;headerlink&quot; title=&quot;206. 反转链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list/&quot;&gt;2</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://hexofox.gitee.io/tags/leetcode/"/>
    
    <category term="双指针" scheme="https://hexofox.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="链表" scheme="https://hexofox.gitee.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="递归" scheme="https://hexofox.gitee.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>58 - II. 左旋转字符串</title>
    <link href="https://hexofox.gitee.io/2023/03/03/58-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://hexofox.gitee.io/2023/03/03/58-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-03-03T01:11:26.000Z</published>
    <updated>2023-03-20T06:26:22.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="58-II-左旋转字符串"><a href="#58-II-左旋转字符串" class="headerlink" title=" 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/"> 58 - II. 左旋转字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre class=" language-python"><code class="language-python">字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串<span class="token string">"abcdefg"</span>和数字<span class="token number">2</span>，该函数将返回左旋转两位得到的结果<span class="token string">"cdefgab"</span>。来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>zuo<span class="token operator">-</span>xuan<span class="token operator">-</span>zhuan<span class="token operator">-</span>zi<span class="token operator">-</span>fu<span class="token operator">-</span>chuan<span class="token operator">-</span>lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class=" language-python"><code class="language-python">示例 <span class="token number">1</span>：输入<span class="token punctuation">:</span> s <span class="token operator">=</span> <span class="token string">"abcdefg"</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span>输出<span class="token punctuation">:</span> <span class="token string">"cdefgab"</span>示例 <span class="token number">2</span>：输入<span class="token punctuation">:</span> s <span class="token operator">=</span> <span class="token string">"lrloseumgh"</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">6</span>输出<span class="token punctuation">:</span> <span class="token string">"umghlrlose"</span> 限制：<span class="token number">1</span> <span class="token operator">&lt;=</span> k <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">10000</span>来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>zuo<span class="token operator">-</span>xuan<span class="token operator">-</span>zhuan<span class="token operator">-</span>zi<span class="token operator">-</span>fu<span class="token operator">-</span>chuan<span class="token operator">-</span>lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="1-空间复杂度0（1）"><a href="#1-空间复杂度0（1）" class="headerlink" title="1. 空间复杂度0（1）"></a>1. 空间复杂度0（1）</h3><p><code>**不能申请额外空间，只能在本串上操作**。</code></p><ol><li><p>反转区间为前n的子串</p></li><li><p>反转区间为n到末尾的子串</p></li><li><p>反转整个字符串</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201426401.png" alt="image-20230303091415542"></p></li></ol><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    string reverseLeftWords(string s, int n) &#123;        reverse(s.begin(), s.begin() + n);        reverse(s.begin() + n, s.end());        reverse(s.begin(), s.end());        return s;    &#125;&#125;;</code></pre><h3 id="2-空间复杂度为0-n"><a href="#2-空间复杂度为0-n" class="headerlink" title="2. 空间复杂度为0(n)"></a>2. 空间复杂度为0(n)</h3><p><code>字符串倍增</code>成<code>为两个同样的字符串拼接的长字符</code>串然后想旋转均可.</p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201426062.png" alt="image-20230303091541113" style="zoom:200%;" /><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    string reverseLeftWords(string s, int n) &#123;        int len = s.size();        s += s;        return s.substr(n,len);    &#125;&#125;;</code></pre><blockquote><p> 时间复杂度都是 0（N）</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><strong><a href="https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">代码随想录 (programmercarl.com)</a></strong></p><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/zi-fu-chuan-pin-jie-yu-qie-fen-pei-tu-by-1smm/">https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/zi-fu-chuan-pin-jie-yu-qie-fen-pei-tu-by-1smm/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;58-II-左旋转字符串&quot;&gt;&lt;a href=&quot;#58-II-左旋转字符串&quot; class=&quot;headerlink&quot; title=&quot; 58 - II. 左旋转字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/zuo-xuan</summary>
      
    
    
    
    
    <category term="字符串" scheme="https://hexofox.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="leetcode" scheme="https://hexofox.gitee.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>图深度学习知识点</title>
    <link href="https://hexofox.gitee.io/2023/03/02/%E5%9B%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://hexofox.gitee.io/2023/03/02/%E5%9B%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2023-03-02T11:42:35.000Z</published>
    <updated>2023-03-20T06:20:14.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图深度学习知识点"><a href="#图深度学习知识点" class="headerlink" title="图深度学习知识点"></a>图深度学习知识点</h1><h2 id="1-KL散度"><a href="#1-KL散度" class="headerlink" title="1. KL散度"></a>1. KL散度</h2><blockquote><p>1 .概念</p></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418669.png" alt="image-20230302194935944"></p><p>两者是等价的 </p><p><code>p(x)和分布q(x)之间的**相对熵(relative entropy)或者KL散 度( Kullback-Leibler divergence )**</code></p><blockquote><ol start="2"><li>性质</li></ol></blockquote><ol><li>不对称性。</li></ol><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418725.png" alt="image-20230302195053926"></p><pre><code>2. KL 散度大于等于0</code></pre><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418472.png" alt="image-20230302195118638"></p><p>参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/39682125">KL散度理解 - 知乎 (zhihu.com)</a></p><blockquote><ol start="3"><li>KL 的理解</li></ol></blockquote><p><code>P往往用来表示样本的真实分布：未知分布</code></p><p><code>Q用来表示模型所预测的分布：模拟p的近似分布</code></p><p><code>那么KL散度就可以计算两个分布的差异，也就是Loss损失值。</code></p><p><strong>从KL散度公式中可以看到<code>Q的分布越接近P（Q分布越拟合P）</code>，那么散度值<code>越小，即损失值越小。</code></strong></p><p><a href="https://zhuanlan.zhihu.com/p/74075915">交叉熵、相对熵（KL散度）、JS散度和Wasserstein距离（推土机距离） - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/question/41252833/answer/195901726">(99+ 封私信 / 80 条消息) 如何通俗的解释交叉熵与相对熵？ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/37452654">初学机器学习：直观解读KL散度的数学概念 - 知乎 (zhihu.com)</a></p><blockquote><ol start="4"><li>KL 散度公式中有带负号有的不带负号为什么？</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418038.png" alt="image-20230302213047904"></p><h2 id="2-贝叶斯公式"><a href="#2-贝叶斯公式" class="headerlink" title="2. 贝叶斯公式"></a>2. 贝叶斯公式</h2><blockquote><ol><li>先验和后验</li></ol></blockquote><p><code>先验概率：因得果</code>:已经知道 p(z)</p><p><code>后验概率：果推因来计算条件概率</code>：未知 p(z|X)</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418407.png" alt="image-20230303134332912"></p><blockquote><ol start="2"><li>贝叶斯推断和决策</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418346.png" alt="image-20230303135906006"></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418206.png" alt="image-20230303135506642"></p><h2 id="3-高斯混合模型"><a href="#3-高斯混合模型" class="headerlink" title="3.高斯混合模型"></a>3.高斯混合模型</h2><blockquote><ol><li>单高斯模型</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418300.png" alt="image-20230303131651155"></p><p><a href="https://zhuanlan.zhihu.com/p/30483076">高斯混合模型（GMM） - 知乎 (zhihu.com)</a></p><blockquote><ol start="2"><li>几何角度理解</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418238.png" alt="image-20230303131446093"><br>$$<br>\begin{array}{l}<br>p(x)=\sum_{k=1}^{N} {\alpha_{k} N\left(x \mid \mu_{k} ,\Sigma_{k}\right)} \<br>\sum_{k=1}^{N}\alpha_{k}=1 \<br>\end{array}<br>$$</p><blockquote><ol start="3"><li>混合角度理解高斯</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418094.png" alt="image-20230303133217965"></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418001.png" alt="image-20230303133030693"></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418077.png" alt="image-20230303133616917"></p><p>$$<br>\begin{aligned}<br>p(x) &amp; =\sum_{z} p(x, z) \<br>&amp; =\sum_{k=1}^{k} p\left(x, z=c_{k}\right) \<br>&amp; =\sum_{k=1}^{K} p\left(z=c_{k}\right) \cdot p\left(x \mid z=c_{k}\right) \<br>&amp; =\sum_{k=1}^{K} p_{k} \cdot N\left(x \mid \mu_{k}, z_{k}\right)<br>\end{aligned}<br>$$</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201419145.png" alt="image-20230320141935089"></p><blockquote><p>总结 </p></blockquote><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418933.png" alt="image-20230303131616932"></p><p>参考链接：<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV13b411w7Xj">https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV13b411w7Xj</a></p><p><a href="https://www.bilibili.com/video/BV1aE411o7qd?p=67&vd_source=5e8f069711510b3788382a0a03ff38e5">(系列十一) 高斯混合模型2-极大似然_哔哩哔哩_bilibili</a></p><p><a href="https://www.zhihu.com/topic/20326197/top-answers">(99+ 封私信 / 80 条消息) 高斯混合模型 - 知乎 (zhihu.com)</a></p><h2 id="4-student-t分布"><a href="#4-student-t分布" class="headerlink" title="4. student t分布"></a>4. student t分布</h2><p>对于 <code>i 样本和 j</code> 样本，我们使用 Student 的 <code>t 分布</code>作为核心来度量<code>嵌入点 hi 和聚类中心向量 μj</code> 之间的相似性，如下所示：</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201418875.png" alt="image-20230306213807740"></p><p><code>qij</code>可以看作是将<code>样本i分配</code>给<code>聚类j的概率</code>，即软分配。</p><p><strong><code>注意点：</code></strong> <strong><code>t=1</code></strong>  </p><p>解释</p><p>我们无法在<strong>无监督环境中对验证集上的 t 进行交叉验证</strong>，并且<strong>学习它是多余的</strong>（van der Maaten，2009），我们让<strong>所有实验的 t= 1</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图深度学习知识点&quot;&gt;&lt;a href=&quot;#图深度学习知识点&quot; class=&quot;headerlink&quot; title=&quot;图深度学习知识点&quot;&gt;&lt;/a&gt;图深度学习知识点&lt;/h1&gt;&lt;h2 id=&quot;1-KL散度&quot;&gt;&lt;a href=&quot;#1-KL散度&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="图深度学习" scheme="https://hexofox.gitee.io/tags/%E5%9B%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>151. 反转字符串中的单词</title>
    <link href="https://hexofox.gitee.io/2023/03/02/151.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>https://hexofox.gitee.io/2023/03/02/151.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2023-03-02T08:07:24.000Z</published>
    <updated>2023-03-20T06:24:03.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre class=" language-python"><code class="language-python">给你一个字符串 s ，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>reverse<span class="token operator">-</span>words<span class="token operator">-</span><span class="token keyword">in</span><span class="token operator">-</span>a<span class="token operator">-</span>string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class=" language-python"><code class="language-python">示例 <span class="token number">1</span>：输入：s <span class="token operator">=</span> <span class="token string">"the sky is blue"</span>输出：<span class="token string">"blue is sky the"</span>示例 <span class="token number">2</span>：输入：s <span class="token operator">=</span> <span class="token string">"  hello world  "</span>输出：<span class="token string">"world hello"</span>解释：反转后的字符串中不能存在前导空格和尾随空格。示例 <span class="token number">3</span>：输入：s <span class="token operator">=</span> <span class="token string">"a good   example"</span>输出：<span class="token string">"example good a"</span>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。 提示：<span class="token number">1</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">104</span>s 包含英文大小写字母、数字和空格 <span class="token string">' '</span>s 中 至少存在一个 单词来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>reverse<span class="token operator">-</span>words<span class="token operator">-</span><span class="token keyword">in</span><span class="token operator">-</span>a<span class="token operator">-</span>string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><code>对于字符串不可变的语言</code>，首先得把字符串转化成其他可变的数据结构，同时还需要在转化的过程中去除空格。</p><p><code>java python</code></p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201423307.png" alt="image-20230302161254310"></p><p><code>对于字符串可变的语言 c++</code>，就不需要再额外开辟空间了，直接在字符串上原地实现。在这种情况下，反转字符和去除空格可以一起完成</p><p><img src="https://raw.githubusercontent.com/GhyJn0/2023images/master/202303201424192.png" alt="image-20230302161410390"></p><ol><li><code>**移除多余空格**</code>      </li><li><code>**反转整个字符**</code></li><li><code>**依次反转每个单词**</code></li></ol><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    void reverse(string& s, int start, int end)&#123; //翻转，区间写法：左闭右闭 []        for (int i = start, j = end; i < j; i++, j--) &#123;            swap(s[i], s[j]);        &#125;    &#125;    void removeExtraSpaces(string& s) &#123;//去除所有空格并在相邻单词之间添加空格, 快慢指针。        int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html        for (int i = 0; i < s.size(); ++i) &#123; //            if (s[i] != ' ') &#123; //遇到非空格就处理，即删除所有空格。                if (slow != 0)                     s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。                while (i < s.size() && s[i] != ' ') &#123; //补上该单词，遇到空格说明单词结束。                    s[slow++] = s[i++];                &#125;            &#125;        &#125;        s.resize(slow); //slow的大小即为去除多余空格后的大小。    &#125;    string reverseWords(string s) &#123;        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。        reverse(s, 0, s.size() - 1);        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。        for (int i = 0; i <= s.size(); ++i) &#123;            if (i == s.size() || s[i] == ' ') &#123; //到达空格或者串尾，说明一个单词结束。进行翻转。                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。                start = i + 1; //更新下一个单词的开始下标start            &#125;        &#125;        return s;    &#125;&#125;;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>空间复杂度：<strong>O(1)</strong></p><p>时间复杂度：O（N)</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录 (programmercarl.com)</a></p><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/">https://leetcode.cn/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;151-反转字符串中的单词&quot;&gt;&lt;a href=&quot;#151-反转字符串中的单词&quot; class=&quot;headerlink&quot; title=&quot;151. 反转字符串中的单词&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/reverse-</summary>
      
    
    
    
    
    <category term="字符串" scheme="https://hexofox.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="leetcode" scheme="https://hexofox.gitee.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="https://hexofox.gitee.io/2023/03/02/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://hexofox.gitee.io/2023/03/02/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</id>
    <published>2023-03-02T01:19:38.000Z</published>
    <updated>2023-03-02T01:41:36.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre class=" language-python"><code class="language-python">请实现一个函数，把字符串 s 中的每个空格替换成<span class="token string">"%20"</span>。</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class=" language-python"><code class="language-python">示例 <span class="token number">1</span>：输入：s <span class="token operator">=</span> <span class="token string">"We are happy."</span>输出：<span class="token string">"We%20are%20happy."</span> 限制：<span class="token number">0</span> <span class="token operator">&lt;=</span> s 的长度 <span class="token operator">&lt;=</span> <span class="token number">10000</span>来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>ti<span class="token operator">-</span>huan<span class="token operator">-</span>kong<span class="token operator">-</span>ge<span class="token operator">-</span>lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><ol><li><p>统计字符串数组中空格的个数</p></li><li><p>扩充数组到每个空格替换成 %20之后的大小。</p></li><li><p>然后从后向前替换空格，也就是双指针法，过程如下：</p><pre><code>     1. i 指向新长度的末尾。     2. j 指向旧长度的末尾。</code></pre></li></ol><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    string replaceSpace(string s) &#123;        int Initlen=s.size();//统计字符串的长度        int count=0;//统计空格的个数        for(auto &a:s)            if(a==' ')                count++;        // 扩充字符串s的大小，也就是每个空格替换成"%20"之后的大小        s.resize(Initlen+2*count);//重塑字符串长度        int Newsize=s.size();        /*         从后先前将空格替换为"%20"*/        for(int i=Initlen-1, j=Newsize-1;i>=0;i--,j--)&#123;            if(s[i]!=' ')&#123;                s[j]=s[i];            &#125;else&#123;                s[j]='0';                s[j-1]='2';                s[j-2]='%';                j-=2;            &#125;        &#125;        return s;    &#125;&#125;;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：<em>O</em>(<em>n</em>)。遍历字符串 <code>s</code> 一遍。</li><li>空间复杂度：O*(*1).由于原地拓展s所以复杂度是0（1）</li></ul><h2 id="总结：数组填充类"><a href="#总结：数组填充类" class="headerlink" title="总结：数组填充类"></a>总结：数组填充类</h2><p><strong><code>其实很多数组填充类的问题，</code></strong></p><p><strong><code>1. 都可以先预先给数组扩容带填充后的大小，</code></strong></p><p><strong><code>2. 然后在从后向前进行操作。 </code></strong></p><p><strong><code>两个好处： </code></strong></p><p><strong><code>1. 不用申请新数组。 </code></strong></p><p><strong><code>2.从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动</code></strong></p><p>作者：Nehzil<br>链接：<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/solution/jian-zhi-offer-05-ti-huan-kong-ge-by-neh-p61r/">https://leetcode.cn/problems/ti-huan-kong-ge-lcof/solution/jian-zhi-offer-05-ti-huan-kong-ge-by-neh-p61r/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指-Offer-05-替换空格&quot;&gt;&lt;a href=&quot;#剑指-Offer-05-替换空格&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 05. 替换空格&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems</summary>
      
    
    
    
    
    <category term="字符串" scheme="https://hexofox.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="数组" scheme="https://hexofox.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="leetcode" scheme="https://hexofox.gitee.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>344. 反转字符串</title>
    <link href="https://hexofox.gitee.io/2023/03/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://hexofox.gitee.io/2023/03/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-03-01T00:53:21.000Z</published>
    <updated>2023-03-01T02:13:31.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><pre class=" language-python"><code class="language-python">编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 的额外空间解决这一问题。来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>reverse<span class="token operator">-</span>string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<span class="token comment" spellcheck="true">###</span></code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class=" language-python"><code class="language-python">示例 <span class="token number">1</span>：输入：s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"h"</span><span class="token punctuation">,</span><span class="token string">"e"</span><span class="token punctuation">,</span><span class="token string">"l"</span><span class="token punctuation">,</span><span class="token string">"l"</span><span class="token punctuation">,</span><span class="token string">"o"</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token string">"o"</span><span class="token punctuation">,</span><span class="token string">"l"</span><span class="token punctuation">,</span><span class="token string">"l"</span><span class="token punctuation">,</span><span class="token string">"e"</span><span class="token punctuation">,</span><span class="token string">"h"</span><span class="token punctuation">]</span>示例 <span class="token number">2</span>：输入：s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"H"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"n"</span><span class="token punctuation">,</span><span class="token string">"n"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"h"</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token string">"h"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"n"</span><span class="token punctuation">,</span><span class="token string">"n"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"H"</span><span class="token punctuation">]</span>来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>reverse<span class="token operator">-</span>string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><img src="../../../../AppData/Roaming/Typora/typora-user-images/image-20230301085904212.png" alt="image-20230301085904212"></p><p><img src="../../../../AppData/Roaming/Typora/typora-user-images/image-20230301085916775.png" alt="image-20230301085916775"></p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><blockquote><p>c++</p></blockquote><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    void reverseString(vector<char>& s) &#123;        int l,r;        l=0;        r=s.size()-1;        while(l<r)&#123;            char temp=s[l];            s[l]=s[r];            s[r]=temp;            l++;            r--;        &#125;    &#125;&#125;;</code></pre><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p><img src="../../../../AppData/Roaming/Typora/typora-user-images/image-20230301085944392.png" alt="image-20230301085944392"></p><h2 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><pre class=" language-python"><code class="language-python">给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>reverse<span class="token operator">-</span>string<span class="token operator">-</span>ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><pre class=" language-python"><code class="language-python">示例 <span class="token number">1</span>：输入：s <span class="token operator">=</span> <span class="token string">"abcdefg"</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span>输出：<span class="token string">"bacdfeg"</span>示例 <span class="token number">2</span>：输入：s <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span>输出：<span class="token string">"bacd"</span>来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">//</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>reverse<span class="token operator">-</span>string<span class="token operator">-</span>ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>反转每个下标从 2<em>k</em> 的倍数开始的，长度为 k 的子串。若该子串长度不足 k*，则反转整个子串。</p><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        for (int i = 0; i < s.size(); i += (2 * k)) &#123;            // 1. 每隔 2k 个字符的前 k 个字符进行反转            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符            if (i + k <= s.size()) &#123;                reverse(s.begin() + i, s.begin() + i + k );            &#125; else &#123;                // 3. 剩余字符少于 k 个，则将剩余字符全部反转。                reverse(s.begin() + i, s.end());            &#125;        &#125;        return s;    &#125;&#125;;</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><img src="../../../../AppData/Roaming/Typora/typora-user-images/image-20230301101034491.png" alt="image-20230301101034491"></p><p><a href="https://leetcode.cn/problems/reverse-string-ii/solution/fan-zhuan-zi-fu-chuan-ii-by-leetcode-sol-ua7s/">541. 反转字符串 II 题解 - 力扣（LeetCode）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;344-反转字符串&quot;&gt;&lt;a href=&quot;#344-反转字符串&quot; class=&quot;headerlink&quot; title=&quot;344. 反转字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/reverse-string/&quot;&gt;344</summary>
      
    
    
    
    
    <category term="字符串" scheme="https://hexofox.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="leetcode" scheme="https://hexofox.gitee.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
