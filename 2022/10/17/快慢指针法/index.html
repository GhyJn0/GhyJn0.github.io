<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="快慢指针, java,安全,python"><meta name="description" content="一个小白成长史"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>快慢指针 | FSRM</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="FSRM" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">FSRM</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom:.6"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">FSRM</div><div class="logo-desc">一个小白成长史</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li><li><div class="divider"></div></li><li><a href="https://github.com/ghyjn0" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i>Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/ghyjn0" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/18.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">快慢指针</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/leetcode/"><span class="chip bg-color">leetcode</span></a></div></div><div class="col s5 right-align"></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2022-10-17</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp; 2022-10-22</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 720</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp; 2 分</div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><blockquote><p>简介</p></blockquote><p>双指针，指的是在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%81%8D%E5%8E%86&spm=1001.2101.3001.7020">遍历</a>对象的过程中，不是普通的使用单个指针<code>[或者称之为变量]</code>进行访问，而是使用<code>两个相同方向（快慢指针）或者相反方向（对撞指针）的指针</code>进行扫描，从而达到相应的目的。</p><blockquote><p>使用条件</p></blockquote><p><strong>双指针使用条件：不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组。</strong></p><blockquote><p>解决问题</p></blockquote><p><code>双指针类型的题目主要存在于数组，字符串，链表居多。</code></p><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h2><h3 id="1-快慢指针"><a href="#1-快慢指针" class="headerlink" title="1.快慢指针"></a>1.快慢指针</h3><p><strong>快慢指针方法，又称为龟兔赛跑算法</strong>，其基本思想就是<strong>使用两个移动速度不同的指针</strong><code>(快指针是慢指针的X倍，X &gt; 1)</code>在<strong>数组或链表等序列结构上移动</strong>。这种方法对于处理<strong>「环形」链表或数组</strong>非常有用。</p><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>定义快慢指针</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><p>参考连接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiong_min/article/details/120816602?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-120816602-blog-123151269.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-120816602-blog-123151269.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1">(19条消息) 双指针算法原理详解_Mir_小熊同学的博客-CSDN博客</a></p><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><h3 id="2-对撞指针（二分法）"><a href="#2-对撞指针（二分法）" class="headerlink" title="2.对撞指针（二分法）"></a>2.对撞指针（二分法）</h3><h2 id="3-快慢指针-刷题"><a href="#3-快慢指针-刷题" class="headerlink" title="3. 快慢指针(刷题)"></a>3. 快慢指针(刷题)</h2><h3 id="27-移除元素-简单"><a href="#27-移除元素-简单" class="headerlink" title="27. 移除元素(简单)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a>(简单)</h3><blockquote><p>题目描述</p></blockquote><pre class="language-c++"><code class="language-c++">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/remove-element
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre><blockquote><p>示例</p></blockquote><pre class="language-c++"><code class="language-c++">
示例 1：

输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
示例 2：

输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
 

提示：

0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100
通过次数861,786提交次数1,452,275

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/remove-element
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre><blockquote><p>题解</p></blockquote><pre class="language-c++"><code class="language-c++">class Solution &#123;
public:
    int removeElement(vector<int>& nums, int val) &#123;
        int slow,fast,length;
        slow=fast=0;//slow 为慢指针，fast为快指针 同时指向首元素
        length=nums.size();
        while(fast<length)&#123;
            if(nums[fast]!=val)&#123;//这里面类似于 slow是一个数组，fast 遍历原数组。把原数组的东西复制到了slow移动的数组中
                nums[slow]=nums[fast];
                slow++;
                fast++;
            &#125;else&#123;
                fast++;
            &#125;
        &#125;
        return slow;
    &#125;
&#125;;
</int></code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"></p><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h3><blockquote><p>题目描述</p></blockquote><pre class="language-c++"><code class="language-c++">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。
</code></pre><blockquote><p>示例</p></blockquote><pre class="language-c++"><code class="language-c++">示例 1:

输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
示例 2:

输入: nums = [0]
输出: [0]
 
</code></pre><blockquote><p>解法1 （双指针两次遍历）</p></blockquote><pre class="language-c++"><code class="language-c++">class Solution &#123;
public:
    void moveZeroes(vector<int>& nums) &#123;                      
        int slow,fast,length;
        slow=fast=0;
        length=nums.size();
        while(fast<length)&#123;//循环终止条件
            if(nums[fast]!=0)&#123;//和27.移除目标元素相同
                nums[slow]=nums[fast];
                slow++;
                fast++;
            &#125;
            else&#123;
                fast++;
            &#125;
        &#125;
        while(slow<length)//27.移除相同元素，返回的是移除后的大小，这道题最后自动补零
        &#123;
            nums[slow]=0;
            slow++;  
        &#125;
             
    &#125;
&#125;;
</int></code></pre><blockquote><p>解法2 （借鉴了快速排序的思想）</p></blockquote><p><strong>快速排序的思想</strong>：<strong>快速排序</strong>首先要<strong>确定一个待分割的元素做中间点x</strong>，然后把<strong>所有小于等于x的元素放到x的左边，大于x的元素放到其右边。</strong></p><p><strong>简单描述：（x的左边都小于等于x，右边都大于x)</strong></p><p><strong>思路：</strong></p><p>这里我们可以<strong>用0当做这个中间点</strong>，<strong>把不等于0</strong>(注意题目<strong>没说不能有负数</strong>)的<strong>放到中间点的左边，等于0的放到其右边。</strong><br>这的中间点就是0本身，所以实现起来比快速排序简单很多，我们使用两个指针i和j，只要nums[i]!=0，我们就交换nums[i]和nums[j]</p><pre class="language-c++"><code class="language-c++">class Solution &#123;
public:
    void moveZeroes(vector<int>& nums) &#123;                     
        int slow,fast,length;
        slow=fast=0;
        length=nums.size();
        while(fast<length)&#123;
            if(nums[fast]!=0)&#123;
               int temp=nums[fast];
               nums[fast]=nums[slow];
               nums[slow]=temp;
               slow++;
            &#125;
            fast++;         
        &#125;       
    &#125;
&#125;;
</int></code></pre><p><img src="https://gitee.com/hexofox/foximage/raw/master/images/20221018115833.gif" alt="quickandtwo"></p><p>参考链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/">动画演示 283.移动零 - 移动零 - 力扣（LeetCode）</a></p><h3 id="844-比较含退格的字符串-尾到头"><a href="#844-比较含退格的字符串-尾到头" class="headerlink" title="844. 比较含退格的字符串(尾到头)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a>(尾到头)</h3><blockquote><p>题目详情</p></blockquote><pre class="language-c++"><code class="language-c++">给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/backspace-string-compare
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre><blockquote><p>示例</p></blockquote><pre class="language-c++"><code class="language-c++">给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

 

示例 1：

输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
示例 2：

输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
示例 3：

输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
 

提示：

1 <= s.length, t.length <= 200
s 和 t 只含有小写字母以及字符 '#'
 

进阶：

你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/backspace-string-compare
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre><blockquote><p>题解1 （栈）</p></blockquote><pre class="language-c++"><code class="language-c++">class Solution &#123;
public:
    bool backspaceCompare(string S, string T) &#123;
        return build(S) == build(T);
    &#125;

    string build(string str) &#123;
        string ret;
        for (char ch : str) &#123;
            if (ch != '#') &#123;
                ret.push_back(ch);
            &#125; else if (!ret.empty()) &#123;
                ret.pop_back();
            &#125;
        &#125;
        return ret;
    &#125;
&#125;;

</code></pre><pre class="language-c++"><code class="language-c++">复杂度分析:

时间复杂度：O(N+M)，其中 N 和 M 分别为字符串 S 和 T 的长度。我们需要遍历两字符串各一次。

空间复杂度：O(N+M)，其中 N和 M 分别为字符串 S 和 T 的长度。主要为还原出的字符串的开销。
</code></pre><blockquote><p>题解2 （双指针）</p></blockquote><pre class="language-c++"><code class="language-c++">我将介绍一种常量级空间复杂度的解法：双指针，并且比官方解思路更简单清晰！

由于 # 号只会消除左边的一个字符，所以对右边的字符无影响，所以我们选择从后往前遍历 S，T 字符串。

思路解析：

准备两个指针 i, j 分别指向 S，T 的末位字符，再准备两个变量 skipS，skipT 来分别存放 S，T 字符串中的 # 数量。
从后往前遍历 S，所遇情况有三，如下所示：
    2.1 若当前字符是 #，则 skipS 自增 1；
    2.2 若当前字符不是 #，且 skipS 不为 0，则 skipS自减 1；
    2.3 若当前字符不是 #，且 skipS 为 0，则代表当前字符不会被消除，我们可以用来和 T 中的当前字符作比较。
若对比过程出现 S, T 当前字符不匹配，则遍历结束，返回 false，若 S，T 都遍历结束，且都能一一匹配，则返回 true。
</code></pre><pre class="language-c++"><code class="language-c++">class Solution &#123;
public:
    bool backspaceCompare(string s, string t) &#123;
        int SkipS,SkipT;
        SkipS=SkipT=0;
        int i,j;
        i=s.size()-1;
        j=t.size()-1;
        while(i>=0 || j>=0)&#123;
            // 先找到 s 中第一个需要比较的字符（即去除 # 影响后的第一个待比较字符）
            while(i>=0)&#123;
                if(s[i]=='#')&#123;
                    SkipS++;
                    i--;
                &#125;else if(SkipS>0)&#123;
                    SkipS--;
                    i--;
                &#125;else&#123;
                    break;
                &#125;
            &#125;
              // 再找到 t 中第一个需要比较的字符（即去除 # 影响后的第一个待比较字符）
            while(j>=0)&#123;
                if(t[j]=='#')&#123;
                    SkipT++;
                    j--;
                &#125;else if( SkipT>0)&#123;
                    SkipT--;
                    j--;
                &#125;else&#123;
                    break;
                &#125;
            &#125;
            // 然后开始比较,注意有下面这个 if 条件的原因是：如果 index = 0 位置上为 '#'，则 i, j 会为 -1
            // 而 index = -1 的情况应当处理。
            // (i >= 0 && j >= 0) 为 false 情况为
            if(i>=0&&j>=0)&#123;
                if(s[i]!=t[j])
                    return false;
            &#125;
            // 1. i < 0 && j >= 0
            // 2. j < 0 && i >= 0
            // 3. i < 0 && j < 0
            // 其中，第 3 种情况为符合题意情况，因为这种情况下 s 和 t 都是 index = 0 的位置为 '#' 而这种情况下
            // 退格空字符即为空字符，也符合题意，应当返回 True。
            // 但是，情况 1 和 2 不符合题意，因为 s 和 t 其中一个是在 index >= 0 处找到了待比较字符，另一个没有找到
            // 这种情况显然不符合题意，应当返回 False，下式便处理这种情况。
            
            else if(i>=0||j>=0)&#123;
                return false;
            &#125;
            
            i--;
            j--;
        &#125;
        return true;

    &#125;
&#125;;
</code></pre><pre class="language-c++"><code class="language-c++">复杂度分析
时间复杂度：O(N+M)其中 N 和 M分别为字符串 S 和 T 的长度。我们需要遍历两字符串各一次。

空间复杂度：O(1)。对于每个字符串，我们只需要定义一个指针和一个计数器即可
</code></pre><p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/solution/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/">https://leetcode.cn/problems/backspace-string-compare/solution/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>参考连接：</p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/solution/shuang-zhi-zhen-bi-jiao-han-tui-ge-de-zi-8fn8/">【双指针】比较含退格的字符串 - 比较含退格的字符串 - 力扣（LeetCode）</a></p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/solution/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/">比较含退格的字符串 - 比较含退格的字符串 - 力扣（LeetCode）</a></p><p><code>注意事项：</code></p><p><strong>这个双指针和以往（27，283，80）不同 ：</strong></p><ol><li><strong>两个指针作用在两个数组</strong></li><li><strong>指针遍历方向从尾部到头部</strong></li></ol><h3 id="80-删除有序数组中的重复项-II-中等"><a href="#80-删除有序数组中的重复项-II-中等" class="headerlink" title="80. 删除有序数组中的重复项 II(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a>(中等)</h3><blockquote><p>题目描述信息</p></blockquote><pre class="language-c++"><code class="language-c++">给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre><blockquote><p>示例</p></blockquote><pre class="language-c++"><code class="language-c++">示例 1：

输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
示例 2：

输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。
 

提示：

1 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums 已按升序排列

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre><blockquote><p>题解</p></blockquote><pre class="language-c++"><code class="language-c++">class Solution &#123;
public:
    int removeDuplicates(vector<int>& nums) &#123;
       return removeDuplicateNum(nums,2);// 
    &#125;
    /*   通用解法   */
    int removeDuplicateNum(vector<int> & nums,int k)&#123;//当出现重复数字 个数大于k个时候，保留k个
        int length=nums.size();//计算当前 数组大小
        if(length<=k)//如果当前数据大小小于等于k,就直接返回数组的大小
            return length;
        /* 当前数组大小大于k时候，直接fast从第k+1个开始 
        对应的下表是k (0,1,2,3,....,k),slow为 数组中第k个元素*/
        int slow,fast;
        slow=k-1;//
        fast=k;
        while(fast<length)&#123;
            if(nums[fast]!=nums[slow+1-k])&#123;
                /*
                要保留k个相同的数据，fast要和slow下一次写入位置的第前k个值相比较
                slow下一次写入位置为slow+1 ,故其前第k个值为slow+1-k;
                */
                nums[slow+1]=nums[fast];
                slow++;
            &#125;
            fast++;
        &#125;
        return slow+1;
    &#125;
&#125;;
</int></int></code></pre><p>参考链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solution/shua-chuan-lc-jian-ji-shuang-zhi-zhen-ji-2eg8/">【宫水三叶】一题双解 :「双指针」&amp;「通用」解法 - 删除有序数组中的重复项 - 力扣（LeetCode）</a></p><h3 id="27和80小总结"><a href="#27和80小总结" class="headerlink" title="27和80小总结"></a>27和80小总结</h3><p><img src="https://gitee.com/hexofox/foximage/raw/master/images/20221018104743.png" alt="image-20221018104743587"></p><p><img src="https://gitee.com/hexofox/foximage/raw/master/images/20221018104515.png" alt="image-20221018104515143"></p><h2 id="4-对撞指针"><a href="#4-对撞指针" class="headerlink" title="4.对撞指针"></a>4.对撞指针</h2><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title=" 977. 有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/"> 977. 有序数组的平方</a></h3><blockquote><p>题目描述</p></blockquote><pre class="language-c++"><code class="language-c++">给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
</code></pre><blockquote><p>示例</p></blockquote><pre class="language-c++"><code class="language-c++">示例 1：

输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
示例 2：

输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/squares-of-a-sorted-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre><blockquote><p>题解</p></blockquote><pre class="language-c++"><code class="language-c++">class Solution &#123;
public:
    vector<int> sortedSquares(vector<int>& nums) &#123;
       int l,r,k;
       l=0;
       k=r=nums.size()-1;
       vector<int>result(nums.size(), 0);//定义一个新的数组存储保存平方的数据
        while(l<=r)&#123;
           int l2=nums[l]*nums[l];
           int r2=nums[r]*nums[r];
            if(l2>r2)&#123;//l左边指针的值小于r右边指针的值 把最大的存储到新数组result末尾。然后l++.
                result[k]=l2;
                k--;
                l++;
            &#125;else&#123;
                result[k]=r2;
                k--;
                r--;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;
</int></int></int></code></pre><p>参考链接：</p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/">有序数组的平方 - 有序数组的平方 - 力扣（LeetCode）</a></p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/solution/acm-xuan-shou-tu-jie-leetcode-you-xu-shu-h8le/">977. 有序数组的平方 题解 - 力扣（LeetCode）</a></p><blockquote><p>复杂度分析</p></blockquote><pre class="language-c++"><code class="language-c++">
时间复杂度：O(n)，其中 n 是数组 nums 的长度。

空间复杂度：O(1)。除了存储答案的数组以外，我们只需要维护常量空间。

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者: </i></span><span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">FSRM</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接: </i></span><span class="reprint-info"><a href="https://hexofox.gitee.io/2022/10/17/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95/">https://hexofox.gitee.io/2022/10/17/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95/</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明: </i></span><span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">FSRM</a> !</span></div></div><script async defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/leetcode/"><span class="chip bg-color">leetcode</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/2022/10/20/KNN/"><div class="card-image"><img src="/medias/featureimages/13.jpg" class="responsive-img" alt="K近邻法:KNN"> <span class="card-title">K近邻法:KNN</span></div></a><div class="card-content article-content"><div class="summary block-with-text">K近邻法 （KNN）1.简介K近邻（K-Nearest Neighbor, KNN）是一种最经典和最简单的有监督学习方法之一，K-近邻算法是最简单的分类器。 K近邻算法既能够用来解决分类问题，也能够用来解决回归问题。当对数据的分布只有很少或</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2022-10-20 </span><span class="publish-author"><i class="fas fa-user fa-fw"></i> FSRM</span></div></div><div class="card-action article-tags"><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="chip bg-color">机器学习</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/2022/10/14/%E8%BF%87%E6%8B%9F%E5%90%88%E5%92%8C%E6%AC%A0%E6%8B%9F%E5%90%88/"><div class="card-image"><img src="/medias/featureimages/21.jpg" class="responsive-img" alt="过拟合和欠拟合"> <span class="card-title">过拟合和欠拟合</span></div></a><div class="card-content article-content"><div class="summary block-with-text">过拟合1.定义机器学习模型在一批数据上过于纠结误差值，想要将误差降到最低。然而当此模型运用到现实数据或者说测试数据上，误差值变高，泛化能力差，不能表达除训练数据以外的其他数据，这就叫做过拟合。如红线 简单表达：模型过于复杂（参数个数太多和参</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2022-10-14 </span><span class="publish-author"><i class="fas fa-user fa-fw"></i> FSRM</span></div></div><div class="card-action article-tags"><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="chip bg-color">深度学习</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0===window.getSelection||(""+(n=window.getSelection())).length<Number.parseInt("120")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: FSRM<br />文章作者: FSRM<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200))})</script><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h2, h3, h4"});let t=0,e="toc-heading-",n=($("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4").each(function(){$(this).attr("id",e+ ++t)}),parseInt(.4*$(window).height()-64)),o=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>n?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});const i="expanded";let c=$("#toc-aside"),a=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){c.hasClass(i)?(c.removeClass(i).hide(),a.removeClass("l9")):(c.addClass(i).show(),a.addClass("l9"));{var t,n="prenext-posts";let e=$("#"+"artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#"+n).width(t)}return}})})</script></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2020</span> <a href="/about" target="_blank">FSRM</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">67k</span>&nbsp;字<br><br></div><div class="col s12 m4 l4 social-link"><a href="https://github.com/GhyJn0" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0],e=(t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",document.getElementsByTagName("script")[0]);e.parentNode.insertBefore(t,e)}()</script><script src="/libs/others/clicklove.js" async></script><script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async></script><script src="/libs/instantpage/instantpage.js" type="module"></script></body></html>